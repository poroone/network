

# ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730906405934-c768a98e-8313-4848-ae57-7b65be0c2f23.png)C\C++跨平台原理
C\C++ 代码会根据不同平台进行编辑对应平台的格式 

windows(PE格式)     Mac(Mach-O格式)     Linux(ELF格式)

<font style="color:#DF2A3F;">! C\C++的跨平台:使用平台想换的编译器生成对应平台的可执行文件</font>

<font style="color:#DF2A3F;">C\C++编译后就可以直接生成平台对应的可执行文件</font>

# java的跨平台原理
1. *.java  =编译=>  *class(字节码文件 对操作系统来说是不可执行文件)
2. 在对应的平台安装JVM java虚拟机 
3. <font style="color:#DF2A3F;">JVM会加载*.class字节码进行解析字节码文件 后进行解析对应平台的机器码</font>
4. <font style="color:#DF2A3F;">一次编译到处运行</font>
5. 如果代码有语法错误,编译失败就不会生成字节码文件 
6. 从而就不会运行JVM程序 最后导致ajva程序运行失败

<font style="color:#DF2A3F;"> </font>

# 网络协议
1. HTTP HTTPS SMTP MQTT REMP
2. 在特定的场景下用特定的协议，效果会更高 如处理文件FTP
3. 第三方库如: ios - AFN anroid - OKHTTP3

# 网络协议模型
ISO国际标准化组织在1985年制定了网络互连模型

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1724833950209-623ff274-b2e4-42e4-865c-ece461e61c4b.png)

> OSI7层参考模型
>

---

7.应用层

6.表示层

5.会话层

4.传输层

3.网络层

2.数据链路层

1.物理层

> TCP/IP-协议
>

---

4.应用层

3.传输层

2.网络层

1.网络接口层



> 用于研究
>

---

5.应用层

4.传输层

3.网络层

2.数据链路层

1.物理层

# 网络基础概念
MAC地址 IP地址 路由器 交换机 集线器 同轴电缆



> 计算机之间的通信基础
>

1. 需要知道计算机的ip地址
2. 需要知道计算机的Mac地址(网卡地址),输送数据包到网卡,被网卡接收
3. 如果网卡发现数据的目标mac不是自己,就会将数据丢弃,不会传递给上一层进行处理
4. 数据包中会有
    1. 源ip地址 ->目标ip地址
    2. 源mac地址 ->目标mac地址
    3. 等

# 网络设备之间的通信
> 有线连接 - 交叉线网线  直连
>

1. 如何拿到MAC地址 

在第一次发送ICMP协议的时候需要知道对方的ip和MAC地址

从而进行ARP协议(广播协议)只要和他相连接通的设备都会收到这个广播(广播只能同一个网段传播的)

ARP协议为了拿到对方的mack地址(并且具有缓存效果)

    1. ARP完整的一次协议 会进行三步
        1. 进行组包
        2. 进行发送
        3. 进行返MAC

当发送广播的时候目标mack地址是FFFF.FFFF.FFFF (F十六进制在二进制中是1)代表全发送全网段也就是广播全接收

> 有线连接 
>

1. **网线(交叉线)直接连接两台电脑**
2. ****
    1. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725293965432-a8acdec2-5c6b-49ac-a886-ea014dbb96dd.png)
3. **同轴电缆(半双工通信 容易冲突(冲突域) 不安全全都发 中间断了整个瘫痪 技术老)**
    1. 半双工通信同一时间只允许一个方向的发动
    2. 如果目标有一个多个接收会冲突进行等待下次随机时间发送
    3. 同轴电缆在发送后,会往每个地方都会发送可能会被抓包
    4. 如果中间断开那么信号可能会回来发送给自己从而瘫痪,影响整条线上的设备
    5. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725285782659-024f38aa-7e7c-4b36-9e6f-cf15e1699f5b.png)
4. **集线器(Hub)(半双工通信 容易冲突 不安全 和同轴电缆一样没智 商)**
    1. 同一时间也只允许同一方向的发送
    2. 目标有多个接受会冲突,等待一会会重新发送
    3. 可能会被抓包
    4. 但是其中一个发生问题不会影响到其他的设备
    5. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725286068656-3617c005-2093-4ee1-a230-9587ee5cd69e.png)
5. **网桥(有学习性 隔绝冲突域 )**
    1. 网桥会维护一个表( ip MAC)
    2. 会进行判断发送请求的方向如果是发送方当前域就不会发给别的域
    3. 从而实现隔断,并且可以使域之间内部同时通信不会有冲突 
    4. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725288182392-a3cc4683-da1c-427d-badb-b08eacbe0bd6.png)
6. **交换机 (Switch 局域网的最终方案 | 相当于更多接口的网桥 全双工通信 安全)**
    1. 可以同时进行来回通信
    2. 具有学习能力可以记录 ip mac在记录后不会广播发送 会指定目标发送
    3. 因为会记录所以更加安全,发的包不会发送到别的设备上从而防止被抓包的风险
    4. 如果全球的设备都用交换机连接会形成广播风暴
    5. 
    6. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725293535474-bf527450-f04d-4e05-a6b9-5c2a7835204a.png)
7. **网线直连,同轴电缆,集线器,网桥,交换机**
    1. 连接设备都需要在同一网段 	<font style="color:#74B602;">192.168.1.</font>20 | <font style="color:#74B602;">192.168.1.</font>10   
    2. 连接设备都必须处在同一广播域
8. **路由器(router 隔绝广播域)**
    1. 主机在发送数据之前,首先会判断目标主机的IP地址跟它是否在同一个网段
        1. 在同一个网段:ARP协议 通过交换机\集线器传递数据
        2. 在不同网段:通过路由器转发数据
    2. 网关层(Gateway)
    3.    ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725293851042-3fa6cdf0-206f-448e-9963-14d3cccd7094.png)

# MAC地址
每个网卡都有一个6字节(48bit)的MAC地址(Media Access Control Address)

全球唯一,固化在网卡的ROM中,由IEEE802标准规定

1. 前三个字节OUI ,组织唯一标识符
2. 由IEEE的注册管理机构分配给厂商
3. oui查询
    1. [standards-oui.ieee.org/oui/oui.txt](https://standards-oui.ieee.org/oui/oui.txt)
    2. [MAC地址查询 - 根据网卡MAC地址查询厂商信息 - MAC地址查厂商 (bmcx.com)](https://mac.bmcx.com/)

| 资质唯一标识符  |  网络接口标识符 |
| --- | --- |
| 40-80-20 | 0E-6A-7D |


## Mac地址的表示格式
> ipconfig /all 可以查看物理地址(网卡地址) 
>

1. windows中 使用 - 进行连接
    1. xx-xx-xx-xx-xx-xx-xx
2. Linux Android Mac iOS 使用:连接
    1. xx:xx:xx:xx:xx:xx
3. packet Tracer
    1. XXXX:XXXX:XXXX
4. 当48位全为1时,代表广播地址
    1. FF-FF-FF-FF-FF-FFF

>  ARP状态
>

dynamic 动态 学习通过ARP协议获取mac 默认缓存两分钟

static 静态 缓存时间较长

 arp -a [主机地址] :查询ARP缓存

arp -d[主机地址] :删除ARP缓存

arp -s 主机地址 MAC地址 :添加一条缓存信息(这是静态缓存,存储时间较久,不同系统的存储时间不同)

## ARP(Address Resolution Protocol) 译为:地址解析协议
+ 通过ip地址获取MAC地址

## RARP(Reverse Address Resolution Protocol) 译为:逆地址解析协议
+ 使用与ARP相同的报文结构
+ 作用与ARP相反,用于将MAC地址转为IP地址
+ 后来被BOOTP,  DHCP所取代

## ICMP
+ ICMP(Internet Control Message Protocol),译为:互联网控制消息协议
+ IPV4中ICMP被成为ICMPv4,ipv6中的ICMP则被成为ICMPv6
+ 通常用于返回错误信息
    - 如TTL值过期,目的不可达
+ ICMP的错误消息总是包括了源数据并返回给发送者

# IP地址
# IP地址  
最初版本是IPV4 ,32bit(4字节),2019年11月25日,全球的IP地址已经用完

后推出ipv6版本 128bit(16字节)

| 1100 0000 | 1010 1000 | 0000 0010 |  0000 0110 |
| --- | --- | --- | --- |
| 第一部分 | 第二部分 | 第三部分 | 第四部分 |
| 192 | 168 | 2 | 6 |


1. ip地址由于两个部分组成:网络标识(网络ID),主机标识(主机ID)
    1. 同一网段的计算机,网络ID相同
    2. 通过子网掩码(subnet mask) 可以计算出网络ID :子网掩码& IP地址

---

IP地址:192.168.2.6

子网掩码:255.255.255.0

网段:192.168.2.0

当前网段可用的主机数是 256-2 应为0(主机位全0代表一个网段) 和255(广播)不可用

---



当子网掩码是1的时候原本ip是什么就是什么

1. 子网掩码是0的时候都是0
    1. 1100 0000 . 1010 1000 . 0000 0010 . 0000 0110
    2. 1111 1111 . 1111 1111 . 1111 1111 . 0000 0000
1. 计算后的 网段192.168.2.0
    1. 网络id 192.168.2
    2. 主机id .0 

## IP地址的分类


1. A类
    1. 网络id必须0开头(8bit) 主机ID (24bit)
    2. 默认子网掩码是255.0.0.0
    3.   ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725351851596-8b3096c6-f08b-48b4-b130-f011b9911e8e.png)
2. B类
    1. 网络id必须10开头(16bit) 主机ID (16bit)
    2. 默认子网掩码是255.255.0.0
    3. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725352128339-f0ba486e-6171-4a68-b52c-06399a019f84.png)
3. C类
    1. 网络id必须110开头(24bit) 主机ID (8bit)
    2. 默认子网掩码是255.255.255.0
    3. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725352329448-df7ef60e-9318-4b22-94b4-570175d3edc8.png)
4. D类
    1. 以1110开头,多播地址
    2. 无子网掩码
    3. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725352398473-6d54f12e-0d09-44bd-97c1-54f4b4ee3cc1.png)
5. E类
    1. 以1111开头 保留位今后使用
    2. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725352402334-dd566b83-fbdc-41f0-a53a-0c6b5de7dc74.png)
6. <font style="background-color:#74B602;">只有A\B\C类地址才能分配给主机</font>
7. 主机ID为全0,代表主机所在的网段
8. 主机ID全为1,代表主机所在的网段的全部主机(广播) 

# 子网掩码的CIDR表示方法
CIDR (classless inter-Domain Routing): 无类别域间路由

1. 子网掩码的CIDR表示方法
    1. 123.210.100.200/24 代表子网掩码由24个1 ,也就是255.255.255.0	
    2. 123.210.100.200/16 代表子网掩码由16个1 ,也就是255.255.0.0	

## 子网划分 
> 等长子网划分
>

A子网 :192.168.0.0/25 ,子网掩码:255.255.255.128

192.168.0.1~192.168.0.126 ,126台

B子网 :192.168.0.128/25 ,子网掩码:255.255.255.128

192.168.0.129~192.168.0.254,126台

> 变长子网划分
>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725503733979-17c8c3c3-5204-493f-8da1-24fd46a781a0.png)

1. 设上图是对192.168.0.0/24 进行变长子网划分
    1. C网段  子网掩码是  255.255.255.128 /25  192-223
    2. B网段  子网掩码是  255.255.255.192 /26  128-191
    3. A网段  子网掩码是  255.255.255.224 / 27 0-127
    4. E网段   子网掩码是 255.255.255.252 /30   224-239
    1. D网段  子网掩码是 255.255.255.252 /30   240-255

### 测试
---

A计算机192.168.0.10/24  <==> B计算机192.168.10.10/16 访问

1. 192.168.0.10/24 访问 192.168.10.10的时候会拿自己的子网掩码进行换算
    1. 192.168.0.10/24 => 192.168.0.0
    2. 192.168.10.10/24=>192.168.10.0
    3. 得出真正的ip后发现192.168.0.0 和192.168.10.0不在同一个网段因此无法访问
2. 192.168.10.10/16 访问192.168.0.10/24  的时候同理也会拿自己的子网掩码进行换算
    1. 192.168.10.10/16 => 192.168.0.0
    2. 192.168.0.10/16 => 192.168.0.0
    3. 得出真正的ip后发现192.168.0.0 和192.168.0.0在同一个网段因此B计算机可以访问A计算机
3. 当一个计算机要访问另外一个计算机时会拿自己的子网掩码去进行换算不会拿对方的子网掩码如果在同一个网段就可以进行访问

## 超网
和子网反过来,他是将多个连续的网段合并成一个更大的网段

如一个有200台计算机使用192.168.0.0/24网段 ,现在希添加200台设备到同一网段

如果有200台设备在192.168.1.0/24网段 ,另外200台在192.168.0.0/24网段

可以进行合并 192.168.1.0/24 192.168.1.0/24为一个网段 192.168.0.0/23(子网掩码往左移动一位)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725507970550-1dd3e350-0076-446d-80de-d380b7ebaf65.png)



## 合并网段的规律


1. 假设n是2的k次幂(k>=1)
2. 子网掩码左移K位能够将能够合并n个网段
3. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725510522618-d24d0b32-6349-497c-a859-9186ebe06bdb.png)
4. 假如一个网段的网络号以二进制0结尾,那么由他开始连续的2个网段,能通过左移1位子网掩码进行合并
5. 假如一个网段的网络号以二进制00结尾,那么由他开始连续的4个网段,能通过左移2位子网掩码进行合并
6. 假如一个网段的网络号以二进制000结尾,那么由他开始连续的8个网段,能通过左移3位子网掩码进行合并

## 判断一个网段是子网还是超网
1. 如果当前网络的子网掩码位数比子网掩码多就是子网
2. 如果当前网络的子网掩码位数比子网掩码少就是超网
3. 查看网段是A类网还是B类网还是C类网
    1. A类网的子网掩码是8
    2. B类网的子网掩码是16
    3. C类网的子网掩码是24
    4. -------------------------------------------------------------------------
    5. 25.100.0.0/16是一个A类子网
    6. 200.100.0.0/16是一个C类超网

# 路由
1. 路由器默认情况下只知道和他直连的设备,非直连的网段需要通过静态路由,动态路由告诉他
2. 静态路由
    1. 管理员手动添加路由信息
    2. 适用于小规模网络
3. 动态路由
    1. 路由通过路由算则协议(如 RIP , OSPF)自动获取路由信息
    2. 适用于大规模网络

> 特定主机路由
>

指定了要访问的ip地址 写死

| 网络 | 子网掩码 | 下一跳 |
| --- | --- | --- |
| 192.168.1.10 | 255.255.255.255 | 194.163.1.1 |
| 192.168.2.10 | 255.255.255.255 | 194.163.1.1 |


> 网络路由
>

网段

| 网络 | 子网掩码 | 下一跳 |
| --- | --- | --- |
| 192.168.1.0 | 255.255.255.0 | 194.163.1.1 |
| 192.168.2.0 | 255.255.255.0 | 194.163.1.1 |


> 汇总路由
>

范围写大

| 网络 | 子网掩码 | 下一跳 |
| --- | --- | --- |
| 192.168.0.0 | 255.255.0.0 | 194.163.1.1 |
| 192.168.0.0 | 255.255.0.0 | 194.163.1.1 |


> 默认路由
>

默认直接访问下一个路由

| 网络 | 子网掩码 | 下一跳 |
| --- | --- | --- |
| 0.0.0.0 | 0.0.0.0 | 194.163.1.1 |


# 数据包的传输过程
数据包的传输

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725542936478-286ed426-e099-47c1-8a19-af7d10bcabd4.png)

1. 数据包在最开始传输的时候会进行封装一个数据包大致为下图如果不是当前网段的就会找当前的路由器进行转发
    1. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725525943861-e77a013c-6a35-423d-bfe3-369b4a948ca2.png)
2. 当前路由器发现目标IP不在我这里更改当前MAC地址为当前路由口的MAC和目标路由口的MAC然后发给下一个路由器1
    1. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725543083100-4b48ef0a-027c-40ce-9a8a-d81fa6e13701.png)
3. 直到找到对应的ip
    1. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725543190382-200df401-5533-45ce-b655-0f42d91fd587.png)

# 网络 互联网  因特网
1. 网络 就是多台设备连在一起就是一个小型网络
    1. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725543972822-da891ce9-1aa3-46c8-a340-4a72c7cdc36c.png)
2. 互联网 利用路由器吧多个网段连接起来形成小型的互联网
    1. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725544228647-fc55ba98-2c1f-4372-9a4c-cc95de928717.png)
3. 因特网 全国最大的互联网 就是因特网(Internet)
    1. 将全世界所有的计算机连接在一起
    2. 一般使用大写I开头的Internet特指因特网

## ISP   ( internet 服务提供商)
 如 移动 电信 网通 铁通等 

## 网络分类
1. <font style="background-color:#ECAA04;">局域网</font> ( Local Area Network) LAN
    1. 一般是范围几百米到十几公里内的计算机所构成的计算机网络
    2. 常用于公司 家庭 学校 医院 机关 一栋大楼等
    3. 局域网中使用最广泛的网络技术叫: 以太网(Ethernet)
2. W<font style="background-color:#ECAA04;"></font>LAN (wireless LAN) 无线局域网
3. <font style="background-color:#ECAA04;">城域网</font> (Metroplitan Area Network) MAN
    1. 一般范围是数十公里到数百公里,可以覆盖一个城市
4. <font style="background-color:#ECAA04;">广域网</font>  (Wide Area Netword) WAN
    1. 一般范围是几百公里到几千公里,可以覆盖一个国家,通常都需要租用ISP的线路

## 常见的几种接口
1. FastEthernet 
    1. 快速以太网接口(100M)
2. GigabitEthernet 
    1. 千兆以太网接口
3. Serial (路由器和路由器之间连接)
    1. 串行接口

## 公网IP丶私网IP
1. 公网ip(public)
    1. internet上的路由器只有到达公网的路由表,没有到达私网的路由表
2. 私网ip(Private)
    1. 主要用于局域网,下面是保留的私网网段
        1. A类: 10.0.0.0/8,1个A类网络
        2. B类: 172.16.0.0/16 ~ 172.31.0.0/16, 16个B类网络
        3. C类: 192.168.0.0/24 ~ 192.168.255.0/24,256个C类网络

## NAT 
1. 私网IP访问Internet需要进行NAT转换位公网IP
    1. NAT(Network Address Translation)
2. NAT的特点
    1. 可以节约公网IP资源
    2. 会隐藏内部真实IP
3. NAT的分类
    1. 静态转换
        1. 手动配置NAT映射表
        2. 一对一转换
    2. 动态转换
        1. 定义外部地址池,动态随机转换
        2. 一对一转换
    3. PAT(port Address Translation)
        1. 多对一转换,最大程度节约公网IP资源
        2. 采用端口多路复用方式,通过端口号标识不同的数据流
        3. 目前应用最广泛的NAT实现方式

# 网络分层
## 网络互连模型
ISO 组织在1985年制定了网络互连模型

**OSI参考模型,具有7层结构(参考)**

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726798092299-2dc4f6a5-54cb-4d3f-8853-c36de6cf22ab.png)

**TCP/IP 协议模型,具有4层结构(实际应用)**

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726798137138-fee0ddd9-14b1-4fda-bd5e-538a9813aef8.png)

**网络5层模型(学习研究)**

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726798260061-ed5f33d1-27f7-4a21-96d5-0f11a3bf7c75.png)

### 请求过程
1. 客户端进行对包逐一封装
2. 服务端进行对应的解包
    1. 应用层会携带上报文和用户数据 
    2. 运输层会加上段  确保包的可靠传输 重传机制 包的完整机制
    3. 网络层会加上包 附带源ip和目标ip地址
    4. 数据链路层会加上帧 附带mac地址和目标mac地址
    5. 物理层传输的是比特流

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726798421026-6536ad62-20f5-46a8-9dcb-81d4291caf71.png)

1. 应用层会加上报文和 用户的携带数据
2. 传输层会进行加料加料后会叫做段
3. 网络层会进行封装封装后叫包
4. 数据链路层进行封装后为帧
5. 最后经过物理层后就变成比特流进行传输

##  ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726801322764-22d4df3e-5f48-47ef-89df-d4cc9bac1649.png)
# 物理层(Physical)
> 物理层定义了接口标准 , 线缆标准 , 传输速率,传输方式等
>

## 数字信号 模拟信号
### 模拟信号(Analog Signal)
1. 连续的信号,适合长距离传输
2. 抗干扰能力差,受到干扰时波形变形很难矫正 

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726802294012-c3f8a00f-8b5e-4e04-baac-879f69e7c23f.png)

### 数字信号(Digital Signal)
1. 离散的信号,不适合长距离传输
2. 抗干扰能力强,收到干扰时波形失真可以修复

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726802607525-9030c22f-f018-4bba-8f62-8f9afa14ea93.png)

## 数据通信模型
**局域网通信模型**

    1. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726803156368-b268912d-3e8d-4ca1-89fe-14f21ac3b51f.png)
+ 网线不能超过100米 可通过不停接交换机进行加长

**广域网通信模型**

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726803903763-d1ad0161-9524-4d28-8245-d91a2233cb45.png)

##  信道(Channel)
<details class="lake-collapse"><summary id="ueaa16ae5"><span class="ne-text">信道</span></summary><p id="ub48c9a7f" class="ne-p"><span class="ne-text"> 信道传输的通道,一条传输介质上(比如网线) 上可以有多条信道</span></p></details>
<details class="lake-collapse"><summary id="u2a5fcb49"><span class="ne-text">单工通信</span></summary><ol class="ne-ol"><li id="u5c00f21b" data-lake-index-type="0"><span class="ne-text">信号只能往一个方向传输,任何时候都不能改变信号的传输方向</span></li><li id="u35ba8a1d" data-lake-index-type="0"><span class="ne-text">无线电广播,有线电视广播 </span></li></ol></details>
<details class="lake-collapse"><summary id="u85f73817"><span class="ne-text">半双工通信</span></summary><ol class="ne-ol"><li id="uc10977a3" data-lake-index-type="0"><span class="ne-text">信号可以双向传输,但必须是交替进行,同一时间只能往一个方向传输</span></li><li id="uf0e02df8" data-lake-index-type="0"><span class="ne-text">对讲机  </span></li></ol></details>
<details class="lake-collapse"><summary id="u28645b18"><span class="ne-text">全双工通信</span></summary><p id="ud1e433c3" class="ne-p"><span class="ne-text">信号可以同时双向传输</span></p><p id="u8a64eaaf" class="ne-p"><span class="ne-text">手机</span></p></details>
# 数据链路层(Data Link)
> 链路 : 从一个节点到相邻节点的一段物理线路(有限或 无线) , 中间没有其他交换节点
>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726812677491-0ca733af-5ee3-433e-a77a-d5bd792f6417.png)

1. 数据链路 :  在一条链路上传输数据时,需要有对应的通信协议来控制数据的传输
2. 不同的数据链路,所用的通信协议可能是不同的
3. 广播信道 : CSMA/CD协议 (如同轴电缆,集线器等组成的网络)
4.  点对点信道 : PPP协议(比如两个路由器之间的通信)



1. 数据链路层的三个基本问题
    1. 封装成帧
    2. 透明传输
    3. 差错检验

## 1.封装成帧
会对网络层的数据进行封装 帧数据在中 会在其前面添加帧开始符和尾部添加帧结束符从而进行区分一段数据

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726816861217-bb25f8c6-4bad-4c3d-88b9-18059a09c539.png)

1. 帧 (Frame) 的数据部分
    1. 就是网络层传递下来的数据包（IP数据包,Packet）



1. 最大传输单位MTL(Maximum Transfer Unit)
    1. 每一种数据链路层协议都规定了所能够传送的帧的数据长度上线
    2. 以太网的MTU为1500个字节

## 2.透明传输
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726817219450-f40d9c04-434a-4e29-95bc-51481205cff6.png)

1. 使用SOH  (Start Of Header) 帧开始
2. 使用EOT (End Of Transmission) 作为帧结束符

**数据中一旦出现SOH EOT 就需要进行转义 **

为了防止数据中出现SOH 或EOT从而造成数据被丢弃会对数据进行检测

如果有OSH EOT ESC 会在其前面进行添加一个ESC进行转义

在接收方拿到后会进行去除ESC从而拿到完整的数据

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726817333407-b5bada27-4078-44e6-8061-727755634673.png)

## 3.差错检验
在发送端会将 数据链路层首部和帧的数据部分进行计算 生成FCS 后拼装进行发送

接收端在接收到后也会对 数据链路层首部和帧的数据部分进行计算 用生成的FCS和 发送来的Fcs进行对比如果一样代表数据没有丢失或者改变 否则代表数据有问题 网卡会进行丢包

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726817572472-3a9d329e-df3a-48b3-9885-630dcb6e79f5.png)

## CSMA/CD协议
CSMA/CD协议  (载波侦听多路访问/冲突检测)

---

1. 使用了CSMA/CD的网络可以被称为以太网(Ethernet) ,他传输的是以太网帧
2. 以太网帧的格式是 : Ethernet V2标准,IEEE的802.3标准
3. 使用最多的是Enternet V2标准

---

1. 为了能够检测正在发送的帧是否产生了冲突,以太网的帧至少是64字节

---

1. 用交换机组件的网络,已经支持全双 工通信,不需要再使用CSMA/CD ,但他传输的帧仍然是以太网帧
2. 所以,用交换机组建的网络,依然可以叫做以太网

---

## Ethernet V2帧的格式
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1727187587431-5c2f6bd6-d9c4-44c2-a984-1c6589117c92.png)

MAC层

会生成FCS , FCS 根据数据传输的内容 加 MAC地址和源MAC地址 加 类型(首部) 加 数据生成一个FCS用来代表当前数据

接收方也会生成一个FCS 从而进行对比如果相同代表没有更改过,如果不同代表数据不一致,会进行丢包

数据最多是46-1500 

## Ethernet V2标准 
当数据部分的长度小于46字节时

数据链路层会在数据的后面假如一些字节填充

接收端会将添加的字节去掉 

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1727596649082-288254ad-4b3f-49a6-b640-5ddf27474505.png)

+ 长度总结
    - 以太网帧的数据长度:46-1500字节(蓝色部分)
    - 以太网帧的长度:64-1518字节(源MAC+ 目标MAC+网络类型+数据+FCS)(全部)

## PPP协议(Point to Point Protocol)
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728523348615-27bd0e44-f46e-40d9-b4f1-dfaf178b0997.png)

+ Address字段:图中的值是0xFF,形同虚设,点到点通信不需要源MAC,目标MAC地址
+ Control字段:图中的值是0x03,目前没什么作用
+ Protocol字段:内部用到的协议类型
+ 帧开始符,帧结束符:0x7E

## PPP协议-字节填充
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728539510850-05b88f03-6d3b-4474-8e66-25236356d78d.png)

+ 将0x7E替换成0x7D5E
+ 将0x7D替换成0x7D5D

## 网卡 (在链路层和物理层)
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728539618545-c29ee37d-d44d-4c3d-8e75-5b5c9c58cb36.png)

+ 网卡在收到一个帧,首先会进行差错校验,如果校验通过则接受,否则丢弃
+ wireshark抓到的帧没有FCS,应为他抓到的是差错校验通过的帧(帧尾的FCS会被硬件去掉)

# 网络层(Network)
+ 网络层数据包(IP数据包,Packet)由首部,数据2部分组成
+ 数据:一般由传输层传递下来的数据段(Segment)
+   ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728542077522-2d10eb7c-d0cd-4b3b-9955-bd187f3c5695.png)

## 网络层首部 - 版本,首部长度,区分服务,总长度
+ 版本(version)
    - 占4位
    - 0b0100:IPV4
    - 0b0110:IPV6

#### 首部长度(Header Length)
+ 占4位 ,二进制乘以4才是最终长度
+ 0b0101 : 20(最小值5)
+ 0b1111 : 60(最大值15) 	

#### 网络层首部 - 总长度
+ 总长度
    - 占16位
    - 首部 + 数据的长度之和,最大值是65535 
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728634669752-b10f255f-9e06-439c-914d-89f2db5d6c4a.png)
    - 由于帧的数据不能超过1500字节,所以过大的ip数据包,需要分成片(fragments) 传输给数据链路层
    - 每一片都有自己的网络层首部(ip首部)

#### 网络层首部 - 标识,标志 ,片偏移
+ 标识(ldentification)
    - 占16位
    - 数据包的ID，当数据包过大进行分片时,同一个数据包的所有片的标识都是一样的
    - 有一个计数器专门管理数据包的ID,每发一个数据包,ID就加1
+ 标志(Flags)
    - 占3位
    - 第1位(Reserved Bit) : 保留
    - 第2位(Dont Fragment) : 1代表不允许分片,0发表允许分片
    - 第3位(More Fragments) : 1代表不是最后一片,0代表是最后一片
+ 片偏移(Fragment Offset)
    - 占13为
    - 片偏移乘以8:字节偏移
    - 为保证片偏移能够存储下所以存储的时候使用进行片偏移除以8
    - 每一片的长度一定是8的整数倍数
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728958073471-cb271d02-bb88-4786-9fd6-94c8ddec7431.png)

网络层首部 - 协议,首部校验和,生存时间

+ 协议(Protocol)
+ 占8位
+ 表明所封装的数据是使用了什么协议

| 协议 | ICPM | IGMP | IP | TCP | EGP | IGP | UDP | IPV6 | ESP | OSPE |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 值(十进制) | 1 | 2 | 4 | 6 | 8 | 9 | 17 | 41 | 50 | 89 |


+ 首部校验和(Header Checksum)
    - 用于检查首部是都有错误
+ 生存时间(Time To Live, TTL)
    - 占8位
    - 每个路由器在转发之前将会TTL减1,一旦发现TTL为0，路由器会返回错误报告
    - 观察使用ping命令后的TTL,能够推测出对方的操作系统,中间经过了多少个路由器
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728964743068-1ce17b90-7eb6-470c-9c30-233841f50469.png)

# 传输层(Transport)
+ 传输层有2个协议
+ TCP( Transmission Control Protocol) ,传输控制协议
+ UDP(User Datagram Protocol) ,用户数据报协议
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728969786989-527926a0-8b15-4213-a96e-f341e816e980.png)

## UDP - 数据格式
+ UDP是无连接的,减少了建立和释放连接的开销
+ UDP尽最大能力交付,不保证可靠交付
+ 因此不需要维护一些复杂的参数,首部只有8个字节(TCP的首部至少20个字节)
+ UDP数据部分
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728975031256-76a99cac-ed1a-4426-9c5b-5892693e23c3.png)
+ UDP长度
+ 占16位,首部的长度+数据的长度  

### UDP - 检验和 (Checksum)
+ 检验和的计算内容: 伪首部 + 首部 + 数据
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728975229901-db6390c2-be06-43ff-9bbc-3ffa80d1933a.png)

### 端口(Port)
+ UDP首部中端口是占用2字节
+ 可以推测出端口号的取值范围是:0-65535
+ 客户端的源端口是临时开启的随机端口
+ 防火墙可以设置开启\关闭某些端口来提高安全性

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728978695668-871bc8fb-5beb-4005-b0ec-c39a12d01ebc.png)

+ 常用命令
+ netstat -an : 查看被占用的端口
+ netstat -anb :查看被占用的端口,占用端口的应用程序
+ telnet 主机 端口 :查看是否可以访问主机的某个端口

## TCP
### TCP数据格式
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729434712387-a621860f-a601-431b-8f0a-a88478fec255.png)

### 数据偏移
+ 占4位: 取值范围是 0x0101~0x1111
+ 乘以4:首部长度(Hander Length)
+ 首部长度是20~60字节



+ 保留
+ 占6位置,目前为0

### TCP与UDP头部区别
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729435430919-5ac92194-4d24-4db6-82c8-dcfea3c3d40a.png)

UDP的首部中有16位的字段记录了整个udp报文段的长度(首部+数据)

但是TCP的首部中仅仅有4位的字段记录了TCP报文段的首部长度,并没有字段记录TCP报文段的数据长度



+ UDP首部中占16位的长度字段是冗余的,纯粹是为了保证首部是32bit对齐
+ TCP\UDP的数据长度,完全可以有IP数据包的首部推测出来
    - 传输层的数据长度=网络层的总长度-网络层的首部长度-传输层的首部长度

### TCP - 检验和(Checksum)
跟UDP一样TCP检验和计算内容:伪首部 + 首部 + 数据

伪首部:占用12字节,仅在计算校验和时起作用,不会传递给网络层

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729436506211-62ac5cff-6da0-4d63-ace6-b2153400d6a0.png)

### TCP - 标志位(Flags)
+ URG(Urgent)

当URG= 1,紧急指针字段才有效,表明当前保温段中有紧急数据,应优先尽快传送



+ ACK (Acknowledgment)

当ACK=1时,确认号字段才有效



+ PSH(Push)



+ RST(Reset)

当RST=1时,表明连接中出现严重差错,必须释放连接,然后再重新建立连接  



+ SYN(Synchronization)

当SYN=1,ACK=0时,表明这是一个建立连接的请求

若对方同意建立连接,则回复SYN=1,ACK=1



+  FIN(Finish)

当FIN=1,代表数据发送完毕,要求释放连接

### TCP -  序号 - 确认号 - 窗口
#### 原生 序号 确认号
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729965820441-fd0e9685-51ad-4272-8046-acc3d6b70eff.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729950442628-6dae7875-fcd4-45ce-8623-31bb541080b5.png) 

#### 相对 序号 确认号
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729952190326-0f0d35f4-ff35-4342-af47-967a426d92d5.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729952724387-86d567dc-f1f4-4d1e-b46c-cc63d51dfb24.png) 

+ 序号(Sequence Number)
    - 占4字节
    - 首先,传输过程的每一个字节都会有一个编号
    - 在建立连接后,序号代表:这一次传给对方的TCP数据部分的第一字节的编号

 

+ 确认号(Acknowledgment Number)
    - 占4字节
    - 在建立连接后,确认好代表,期望对方下一次传过来的TCP数据部分的第一个字节的编号



+ 窗口(window)
    - 占2字节
    - 整个字段有流量控制功能,用以告知对方下一次允许发送的数据大小(字节为单位

#### 相对 + 原生 序号 确认号
1. 发送方发送建立连接请求携带 SYN=1首次建立连接 seq=0 ack=0

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729957861347-b950f2c1-6ba5-4ce5-a234-a0bb60c37ef8.png)

2. 接收方响应发送方的请求 携带SYN=1 首次建立简介seq=0 ack=1

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729956730091-beab7e3e-49a4-444d-859b-4aa212936562.png)

3. 发送方收到后知道接收方需要1开头的数据准备发送 SYN=0 已经不是首次建立连接了 seq=1 ack=1

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729957807052-4be59e3c-40d8-4a43-a568-1619bd8d0c87.png)

4. 上方TCP三次握手完毕开始HTTP传输数据 响应上一次接收方的信息 所以seq=1 ack=1

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729964373635-4c5e4b5f-cad0-4d47-8e43-df73a56fce64.png)

5. 开始发送数据 对上一次的数据 所以是 seq=s2+1 ack=s1+k(数据字节)+1 

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729965001826-48f84dda-6966-44dd-9b37-6665d21d4929.png)  
6. 对上一次的数据 seq =s2+b1(上一次发送的部分)+1 ack=s1+k+1

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729965189067-fea83da6-ddba-420c-ae78-700be24a0b6a.png)

7. 对上一次的数据 seq =s2+b1(上上一次发送的数据部分)+b2(上次发送的数据部分)+1 ack=s1+k+1

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729965368025-ef2915f9-754e-443d-b86e-48d8e874905d.png)

8. 对上一次的数据 seq =s2+b1(上上一次发送的数据部分)+b2(上次发送的数据部分)+b3+1 ack=s1+k+1

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729965376654-00f8ac57-ef27-46fb-b39d-7622e43d7f41.png)

9. 收到了对方发送的数据后 返回seq=k+1 ack=b1+b2+b3+b4+1

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729965857251-e6266fd4-f667-41d2-96d0-925afbac1c09.png)

**  第N个包的序号:是前面N-1个包的总长度+1 **

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730023300014-919f39b9-0adc-46d8-b290-6494301d6150.png)

### 可靠控制
#### 停止等待ARQ协议
+ ARQ(Automatic Requeat-reQuest) 自动重传请求

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729439421418-aebbe53c-ea4b-4cac-88de-05953134253b.png)

+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729489237380-5c4e20bb-4134-44cf-a5f4-af157843112e.png)



#### 连续ARQ协议+ 滑动窗口协议
 

+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729489548404-b22ece16-9d13-4b6d-bb5f-e60f4979da0c.png)
+ 如果接收窗口最多能接受4个包
    - 但对方只发送了两个包
+ 接收方如何确定后面还有没有2个包
    - 接收方会等待一定时间后如果没有第三个包
    - 就会返回确认收到2个包给发送方
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729490046884-cdfe259e-4bff-4328-a9ba-62f377ce308d.png)

#### SACK(选择性确认)
+ 在TCP通信过程中,如果发送序列中间某个数据包丢失(比如1 , 2 , <font style="color:#DF2A3F;">3 </font>, 4 , 5 中的<font style="color:#DF2A3F;">3</font>丢失了)
+ TCP会通过重传最后确认的分许后续的分许(最后确认的是2,会重传<font style="color:#DF2A3F;">3</font> 4 5)
+ 这样原先已经正确传输的分组也可能重复发送(比如4 5 ),降低了 TCP 性能
+ 为改善上述情况,发展出SACK(Selective Acknowledgment.,选择性确认 ) 技术
+ 告诉发送方哪些数据丢失,哪些数据已经提前收到
+ 使TCP只重新发送丢失的包(比如 <font style="color:#DF2A3F;">3</font> ),不用发送后续所有的分组(比如4 , 5 )
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729495756193-27626522-6d0a-4d27-a78b-74213583aa40.png)
+ SACK信息会放在TCP首部的选项部分
+ Kind:占1字节,值为5代表这是SACK选项
+ Length:占1字节,表明SACK选项一共占用多少字节
+ left Edge:占4字节左边界
+ Right Edge:占4字节,右边界
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729495911843-04f805e5-ec43-4a82-b35a-8eac00c53477.png)
+ 一对边界信息需要占用8字节,由于TCP首部的选项部分最多40字节,所以
+ SACK选项最大携带4组边界信息
+ SACK选项的最大占用字节数=4*8+2=34

###  流量控制
> 让发送方的发送速率不要太快,让接收方来得及接收处理
>
> 通过确认报文中的窗口字段开控制发送方的发送速率
>
> 发送方的发送窗口大小不能超过接收方给出窗口大小
>

+ 如果接收方的缓存区满了,发送方还在疯狂的发送数据
+ 接收方只能把收到的数据包丢掉,大量的丢包会极大的浪费网络资源
+ 所以要进行流量控制
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729574029416-1c487121-0b49-497c-9f36-286a5fa9c395.png)

#### 特殊控制
一开始,接收给发送方发送了0窗口的报文段

后面,接收方又有了一些存储空间,给发送方发送的非0窗口的报文段丢失了

发送方的发送窗口一直为零,双方陷入僵局

**解决方案**

当发送方收到0窗口通知时,这是发送方停止发送报文

并且同时开启一个定时器,隔一段时间就发送一个测试报文去问询问接收方最新的窗口大小

### 拥塞控制
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729579983786-aa28f0d1-f1dd-4c40-a8d4-fae53cc2879a.png)

#### 拥塞控制
+ 为防止 过多的数据注入到网络中
+ 避免网络中的路由器或链路过载
+ 拥塞控制是一个全局性的过程
+ 以及与降低网络传输性能有关的所有因素
+ 相比而言,流量控制是点对点通信的控制 

#### 拥塞控制 - 方法
1. 慢开始(slow start ,慢启动)
2. 拥塞避免(congestion avoidance)
3. 快速重传(fast retransmit)
4. 快速恢复(fast recovery)

#### 缩写名称
+ MSS(Maximum segment Size) 每个段做大的数据部分大小(在建立连接时)
+ cwnd(congestion window):拥塞窗口
+ rwnd(receive window):接收窗口
+ swnd(send window) :发送窗口( swnd =min(cwnd，rwnd))

#### 慢开始
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729585896423-9c4f9308-b06c-4cf8-a342-8f12e53eb637.png)



![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729689848546-5a827075-3bcf-47d4-b905-7b3ff7f4c347.png)

cwnd的初始值比较小,然后随着数据包被接收方确认(收到一个ack)

cwnd就成倍增长(指数级)

#### 拥塞避免
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729586279634-d0d8829b-9ee6-4887-bcf2-7dd1082c2b7b.png)

+ ssthresh(slow start threshold):慢开始阈值,cwnd达到阈值后,以线性方式增加
+ 拥塞避免(加法增大):拥塞窗口缓慢增大.,以防止网络过早出现堵塞
+ 乘法减小:只要网络出现堵塞,把ssthresh减半,于此同时,执行慢开始算法(cwnd又恢复到初始值)
+ 当网络出现频繁拥塞时,ssthresh值就下降的很快

#### 快重传
+ **接收方**
    - 每收到一个失序列的分组后就立即发出重复确认
    - 使发送方及时知道有分组没有到达
    - 而不是等待自己发送数据时才进行确认
+ **发送方**
    - 只要连续 收到三个重复确认(总共4个相同的确认),就应当立即重传对方尚未收到的报文段
    - 而不必继续等待重传计时器到期后再重传
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729587554623-5f3b2645-4e31-45a8-8b26-76db7c9245dc.png)

#### 快重传 +  快恢复 
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729781289848-5e416658-b64a-41e0-93a7-0a8b2b3c220c.png)

+ **快恢复**
    - 当发送方连续收到三个重复确认,就执行 "乘法减小" 算法，吧ssthresh减半
    - 这是为了预防网络拥塞
    - 由于发送方现在认为网络很可能没有发生拥塞
    - 因此,与慢开始不同之处是现在不执行慢开始算法,即cwnd现在不回复到初始值
    - 而是吧cwnd值设置为ssthresh减半后的数值
    - 然后开始执行拥塞避免算法( ' 加法增大 ' ),使拥塞窗口缓慢地线性增大
+ TCP - 拥塞避免 -发送窗口的最大值

#### 发送窗口的最大值 
+ 发送窗口的最大值 :swnd=min(cwnd,rwnd) 谁小用谁
+ 让rwnd(接收窗口)< cwnd(拥塞窗口)时,是接收方的接受能力限制发送窗口的最大值
+ 当 cwnd < rwnd时,则是网络的拥塞限制发送窗口的最大值

### 连接管理
#### 建立连接
1. **三次握手**
+ CLOSE: client 处于关闭状态
+ LISTEN:server处于监听状态 等待client连接
+ SYN-RCVD:表示server接收到SYN报文,当收到client的ACK报文后,他会进入到ESTABLISHED状态
+ SYN-SENT:表示client已发送SYN报文,等待server的第二次握手
2. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730093568104-1ad45e0c-6a82-4876-a08c-76a9fefe7bb0.png)
3. 前两次握手
+ SYN都设置为1
+ 数据部分的长度都为0
+ TCP头部的长度一般是32字节
    - 固定头部:20字节
    - 选项部分:12字节
4. 双方会交换确认一些信息
5. 比如MSS 是否支持SACK Window scale(窗口缩放系数) 等
6. 这些数据都放在了TCP头部的选项部分中(12字节)
7. **TCP- 建立连接 --疑问**
    1. 为什么建立连接的时候,要进行三次握手,二次不行吗?
        1. 主要目的:防止server端一直等待,浪费资源
    2. 如果建立连接只需要两次握手,可能会出现的情况
    3. 结社client发出的第一个连接请求报文段,应为网络延迟,在连接释放以后的某个时间才到达server
    4. 本来这是一个早已失效的连接请求,但server收到此失效的请求后,误认为是client再次发送一个新的连接请求
    5. 于是server就会像client发出取人报文段,同意建立连接
    6. 如果不采用"三次挥手"，那么只要server发出确认,新的连接就建立了
    7. 由于现在client并没有真正想连接服务器的意愿,因此不会理财server的确认,也不会向server发送数据
    8. 但server却以为新的连接已经建立,并一直等待clinet发送数据,这样,server的很多资源就白白浪费掉了’
8. 采用 "三次握手" 的方法可以防止上述现象发生
9. 例如上述情况,client没有向server的确认发出确认,server由于收不到确认,就知道client并没有要求建立连接
10. 第三次握手失败了怎么处理
    1. 此时server的状态为SYN-RCVD,若等不到client的ack,server会重新发送SYN+ACK包
    2. 如果server多次重发SYN+ACK都等不到client的ACK,就会发送RST包,强制关闭连接
    3. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730220699231-4d072ad9-8750-4a64-bcd7-ffaf6115010d.png)
    4. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730278148200-8f8951e2-0ac4-4e77-924c-5ba407bc4f8a.png)
    5. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730278154226-5eae7919-3633-467e-a99a-81f121541c09.png)

#### 释放连接
##### 四次挥手
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730278683259-052343c5-8ae0-47c0-ab69-933195af7da4.png)

+ 为什么释放连接的时候,要进行四次挥手
+ T CP是全双工模式
+ 第一次挥手:<font style="color:#1DC0C9;">主机1</font>发送FIN报文段时<font style="color:#74B602;"></font>
    - 表示<font style="color:#1DC0C9;">主机1</font>告诉<font style="color:#74B602;">主机2</font>,<font style="color:#1DC0C9;">主机1</font>已经没有数据要发送了,但是,此时<font style="color:#1DC0C9;">主机1</font>还是可以接受来自<font style="color:#74B602;">主机2</font>的数据
+ 第二次挥手:当<font style="color:#74B602;">主机2</font>返回ACK报文段时
    - 表示<font style="color:#74B602;">主机2</font>已经知道<font style="color:#1DC0C9;">主机1</font>没有数据发送了,但是<font style="color:#74B602;">主机2</font>还是可以发送数据到<font style="color:#1DC0C9;">主机1</font>的
+ 第三次挥手:当<font style="color:#74B602;">主机2</font>也发送了FIN报文段时
    - 表示主机2告诉<font style="color:#1DC0C9;">主机1</font>,<font style="color:#74B602;">主机2</font>已经没有数据要发送了
+ 第四次挥手:当<font style="color:#1DC0C9;">主机1</font>返回ACK报文段时
    - 表示<font style="color:#1DC0C9;">主机1</font>已经知道<font style="color:#74B602;">主机2</font>没有数据发送了,随后正式断开整个TCP连接

#### 状态解读
+ FIN-WAIT-1:表示想主动关闭连接
    - 向对方发送FIN报文,此时进入到FIN-WAIT-1状态
+ CLOSE-WAIT:表示正在等待关闭
    - 当对方发送FIN给自己,自己会回应一个ACK报文给对方,此时则进入到CLOSE-WAIT状态
    - 在此状态下,需要考虑自己是否还有数据要发送给多方,如果没有,发送FIN报文给对方
+ FIN-WAIT-2:只要对方发送ACK确认后,主动方就会处于FIN-WAIT-2状态,然后等待对方发送FIN报文
+ CLOSING:一种比较罕见的例外状态
    - 表示你发送FIN报文后,并没有收到对方的ACK报文,反而却也收到了对方的FIN报文
    - 如果双方几乎在同时准备关闭连接的话,那么就出现了双方同时发送FIN报文的情况,也即会出现CLOSING状态
    - 表示双方都正在关闭SOCKET
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730302485071-44981ed6-22d7-4da2-a68f-a2dd9b4e12a4.png) 
+ LASE-ACK:被动关闭一方在发送FIN报文后,最后等待对方的ACK报文
    - 当收到ACK报文后,即可进入CLOSED状态了
+ TIME-WAIT:表示收到对方的FIN报文,并发送出了ACK报文,2MSL后即可进入CLOSED状态
    - 如果FIN-WAIT-1状态,收到对方同时带FIN标志的ACK标志的报文时
    - 可以直接进入到TIM-WAIT状态,而无须经过FIN-WAIT-2状态
+ CLOSED:关闭状态
    - 由于状态的事件比较短暂,所以很难用netstat命令看到,比如SYN-RCVD, FIN-WAIT-1等

##### 细节
+ TCP/IP协议栈在设计上,允许任何一方先发起断开请求,当前说的是client主动要求断开
+ client发送ACK后,需要有一个TIME-WAIT阶段,等待一段时间后,在真正关闭连接 
+ 一般是等待2倍的MSL(Maximum Segment Lifetime,最大分段生存期)
    - MSL是TCP报文在internet上的最长生存时间
    - 每个具体的TCP实现都必须选择一个确定的MSL值, [RFC 1122](https://www.rfc-editor.org/rfc/rfc1122)建议是2分钟
    - 可以防止本次连接中产生的数据包误传到下一次连接中(应为本次连接中的数据包都会在2MSL时间内消失了)
+ 如果client发送ACK后马上释放了,然后又因为网络原因,server没有收到client的ACK,server就会重发FIN
+ 这时可能出现的情况是
    - 1. client没有任何行营,服务器那边回干等,甚至多次重发FIN，浪费资源
    - 2.client有个新的应用程序刚好分配了同一端口号,新的应用程序收到FIN后马上开始执行断开连接的操作,本来他可能是想跟server建立连接的 

##### 抓包	
+ 有的时候在使用抓包工具的时候,有可能只看到  三次  挥手
+ 这其实是将第2,3此挥手合并了
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730380078806-6f7984c0-3e0b-4575-9f00-1ff24ec75ae7.png)
+ 当server接收到client的FIN时,如果server后面也没有数据要发送给client了
+ 这时,server就可以将第2,3此挥手合并,同时告诉client两件事
    - 已经知道client没有数据要发
    - server已经没有数据要发了
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730380836863-d7b1ccc8-44e0-4323-8c85-52876c3ee587.png)



### TCP问题
+ **如果有个包重传了N次还是失败,会一直重传到成功个为止吗?**
+ 这个取决于系统的设置,比如有些系统,重传5次还未成功就会发送reset报文(RST)断开TCP连接

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729563177309-b1b37066-8718-4745-82a3-1298404515ff.png)

+ **为什么选择在传输层就将数据"大卸八块" 分成多段,而不是等到网络层在分片传递给数据链路层**
+ 应为可以提高重传的性能
+ 需要明确的是:可靠传输是在传输层控制的
+ 如果在传输层不分段,一旦出现数据丢失,整个传输层的数据都得重传
+ 如果在传输层分了段,一旦出现数据丢失,只需要重传丢失的那段即可
+ **长连接和短链接是如何区分的**
+ 短连接在发送后会立即关闭
+ 长连接是开发者定义如何关闭

# 应用层
### 应用层的常见协议
+ 超文本传输:HTTP ,HTTPS
+ 文件传输:FTP
+ 邮件协议:SMTP POP2 IMAP
+ 动态主机配置:DHCP
+ 域名协议:DNS
+ 等

### 域名(Domain Name)
+ 由于ip地址不方便记忆,并且不能表达组织的名称和性质,人们设计出了域名(比如baidu.com)
+ 但实际上,为了能够访问具体的主机,最终还是需要知道目标主机的ip地址



+ **域名可分为**
+ 顶级域名
+ 二级域名
+ 三级域名

### 顶级域名的分类
+ 通用的顶级域名(General Top-level Domain 简称gTLD)
    - .com(公司) .net(网络机构) ..org(组织机构) .edu(教育) .gov(政府部门) .int(国际组织)等



+ 国家及地区顶级域名(Country Code Top-level Domain 简称gTLD)
    - .cn(中国) .jp(日本) .uk(英国)



+ 新通用顶级域名(New Generic Top-level Domain 简称gTLD)
    - .vip .xyz .top club .shop等

### 二级域名
+ 二级域名是指顶级域名之下的域名
    - 在通用顶级域名之下,他一般指域名注册人的名称 例如 google baidu microsoft等
    - 在国家及地区顶级域名下,一般指注册类别的,例如com edu gov net 等

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730392286406-63c1d5f3-e8e9-4fb0-884a-8e936b55d44e.png)

### DNS
DNS的全称是:Domain Name System 译为:域名系统

利用DNS协议,可以将域名(比如baidu.com)解析成对应的ip地址(比如 220.180.25.14）

DNS可以基于UDP协议,也可以基于TCP协议 ,服务器占用53端口

 ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730393084017-1862414d-154b-4a7d-b5c7-0666e97075f3.png)

#### DNS命令
+ ipconfig/displaydns :查看DNS缓存记录
+ ipconfig/flushdns:清空DNS缓存记录
+ ping 域名
+ nslookup 域名

#### DNS服务器
+ 客户端首先会访问最近的一台DNS服务器(也就是客户端自己配置的DNS服务器)
+ 所有的DNS服务器都记录了DNS根域名服务器的IP地址
+ 上级DNS服务器记录了下一级DNS服务器的IP地址
+ 全球一共13台ipv4的DNS根域名服务器,25太ipv6的DNS根域名服务器

### IP地址的分配
+ IP地址分配方式,可以分为:静态ip地址,动态ip地址
+ 静态ip地址
    - 手动设置
    - 适用场景:不怎么挪动的台式机(比如学校机房中的台式机),服务器等
+ 动态ip地址w我
+ 
    - 从DHCP服务器自动获取ip地址
    - 使用场景:移动设备,无线设备等

### DHCP
DHCP(Dynamic Host Configuration Protocal) 译为:动态主机配置协议

DHCP协议基于UDP协议,客户端端口是68端口,服务器端口是67端口

DHCP服务器会从ip地址池中,挑选一个ip地址"出租"给客户端一段时间,时间到期就回收他们

平时家里上网的路由器就可以充当DHCP服务器

#### DHCP 分配IP地址的4个阶段
+ DISCOVER:发现服务器
    - 发广播包(源IP是0.0.0.0,目标IP是255.255.255.255 ,目标MAC是FF:FF:FF:FF:FF:FF)
+ OFFER:提供租约
    - 服务器返回可以租用的IP地址,以及租用期限,子网掩码,网关,DNS等信息
    - 可能会有多个服务器提供租约
+ REQUEST:选择IP地址
    - 客户端选择一个OFFER,发送广播包进行回应
+ ACKNOWLEDGE:确认
    - 被选中的服务器发送ACK数据包给客户端

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730703361968-90d56ef0-9d97-4fca-8b5c-a6f564f88ac6.png)

#### DHCP细节
DHCP服务器可以跨网段分配地址,可以借助DHCP中继代理(DHCP Relay Agent) 实现跨网段分配IP地址

+ 自动续约
    - 客户端会在租期不足的时候,自动想DHCO服务器发送REQURET信息申请续约
+ 常用命令
+ ipconfig /all:可以看到DHCP相关的详细信息,比较租约过期时间,DHCP服务器地址等
+ ipconfig /release :释放租约
+ ipconfig /renew :重新申请IP地址,申请续约(延长租期)

### HTTP
> HTTP(Hyper Text Transfer Protocol),译为超文本传输协议
>

+ 是互联网中应用最广泛的应用层协议
+ 设计HTTP最初的目的是,提供一种发布和接受HTML页面的方法,由URI来表示具体的资源
+ 后面用HTTP来传递的数据格式不仅仅是HTML,应用非常广泛
+ HTML(Hyper Text Markop Language):超文本标记语言
+ 用以编写网页

#### 版本
+ 1991年,HTTP/0.9
    - 只支持GET请求方法获取文本数据(比如HTML文档),且不支持请求头,响应头等,无法向服务器传递太多信息
+ 1996年,HTTP/1.0
    - 支持POST,HEAD等请求方式i，支持请求头,响应头等,支持更多种数据类型(不在局限于文本数据)
    - 浏览器的每次请求都需要与服务器建立一个连接TCP连接,请求处理完毕后立即断开TCP连接
+ 1997年,HTTP/1.1(经典皮肤)
    - 支持PUT,DELETE等请求方法
    - 采用持久连接(Connection:keep-alive),多个请求可以共用一个TCP连接
+ 2015年,HTTP/2.0
+ 2018年,HTTP/3.0

#### 标准
HTTP的标准

+ 有万维网协会(W3C),互联网工程任务组(IETF)协议制定,最终发布一系列的RFC
+ RFC(Request For Comments)请求意见稿

HTTP1.1规范

+ 最早在1997年的RFC 2068中记录的
+ 1999年RFC 2068作废 就在RFC 2616中
+ 2014年又由RFC 7230系列RFC取代

HTTP2 标准

+ 与2015年一RFC 7540发表取代HTTP1.1成为HTTP的实现标准

中国的RFC

+ 1996年3月,清华大学提交的使用不同国家和地区中文编码的汉字统一传输标准呗IETF通过为RFC 1922
+ 成为中国大陆第一个被认可为RFC文件的提交协议

#### 报文格式
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730817687149-a6b26350-15e3-414c-a82e-09574e867e66.png)





#### ABNF
ABNF (Augmented BNF)

是BNF (Backus -Naur Form 译为:巴克斯-<font style="color:black;">瑙尔范式</font>)的修改 增强版

在RFC 5234中表明:ABNF作用internet中通信协议的定义语言

ABNF 是最严谨的HTTP报文格式描述形式,脱离ABNF谈论HTTP报文格式,往往都是片面,不严谨的



关于HTTP报文格式ide定义

RFC 2616 4.HTTP Message (旧)

RFC 7230 3.Message Format(新)



#### 报文格式-整体


![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730821882771-8bd20878-e532-4864-be22-5431f195eb72.png)

#### ABNF-核心规则
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730821930596-430f65c1-58d4-4c5b-8497-0b85640a729d.png)

#### 报文格式 -request-line  start-line
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730822600477-bfc69aae-72d2-43a6-9e52-b3525978e4a3.png)

#### 报文格式 - header-filed ,message-body
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730823056312-1c94e510-345c-41d3-bcaa-ff58c002f4fa.png)

#### URL的编码
URL中一旦出现一些特殊的字符(比如中文,英文),需要进行编码

在浏览器地址输入URL时,是采用UTF-8进行编码

#### telnet
使用telnet命令可以直接面向HTTP报文与服务器交互

可以更清晰,直观地看到请求报文,响应报文的内容

可以检验请求报文格式的正确与否

#### 请求方法
REF 7231 描述了 8中请求方法

GET POST PUT DELETE HEAD OPTIONS TRACE CONNECT

REF 5789  描述了PATCH方法

+ GET:常用于读取的操作,请求参数直接拼接在URL的后面(浏览器对URL是有长度限制的)
+ POST:冲用于添加 修改 删除的操作,请求参数可以直接放在请求体中(没有大小限制)
+ HEAD :请求得到与GET请求相同的响应,但没有响应体
    - 使用场景:在下载一个大文件前,先获取其大小,再决定是否要下载,以此可以节约带宽资源
+ OPTIONS:用于获取目的资源所支持的通信选项,比如服务器支持的请求方法
+ OPTIONS HTTP/1.1
+ PUT : 用于对已存在的资源进行整体覆盖  <font style="color:#DF2A3F;">不安全</font>
+ PATCH:用于对资源进行部分修改(资源不存在,会创建新的资源)    <font style="color:#DF2A3F;">不安全</font>
+ DELETE:用于删除指定的资源    <font style="color:#DF2A3F;">不安全</font>
+ TRACE:请求服务器会先其收到的请求信息 ,只要用于HTTP请求的测试和诊断
+ CONNECT:可以开启一个客户端与所请求资源之间的而双向沟通的通道,它可以用来创建渠道(tunnel)
    - 可以用来访问采用了SSL (HTTPS) 协议的站点

#### 头部字段(Header Field)
+ 头部字段可以分为4种类型
+ 请求头字段(Request Header Fields)
    - 有关要获取的资源或客户端本身信息的消息头
+ 响应头字段(Request Header Fields)
    - 有关响应的补充信息,比如服务器本身(名称和版本等)的消息头
+ 是实体头字段(Entity Header Fields)
    - 有关实体主题的更多信息,比如主体长度(Conteng-Length)或其MIME类型
+ 通用头字段(General Header Fields)
    - 同时使用与请求和响应消息,但与消息主体无关的消息头、

#### 请求头字段
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730899985201-b7e00e8e-4d69-4368-b30c-e25a0971109e.png)![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730985264501-7a4930c5-bdcc-4d1f-bbef-f8a20f14d5ef.png)![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730904675216-aaa5c34a-222c-46e1-ac9b-f538e72ed5b0.png)

#### 响应头字段
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730905165836-15a24bab-613e-40b4-beea-f7ced613470e.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730905177280-9d3040c9-dfc8-4236-9e0e-57dc01dd3de5.png) 

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730906179990-40df3b96-7d88-4237-a1a5-56fddb354456.png)

#### 状态码
在RFC 2616 10.Status Code Definitions规范中

状态码提示HTTP请求是否成功完成



+ 状态码分为5类
    - 消息响应:100~199
    - 成功响应:200~299
    - 重定向:300~399
    - 客户端错误:400~499
    - 服务器错误:500~599
+ 100 continue(继续)
    - 请求的初始部分已经被服务器收到,并且没有被服务器拒绝.客户端应该继续发送剩余的请求,如果请求已经完成,就忽略这个响应.
    - 允许客户端发送带请求体的请求前,判断服务器是否愿意接收请求(服务器通过请求头判断)
    - 在某些情况下,如果服务器在不看请求体就拒绝请求时,客户端就发送请求体是不恰当的或低效的



+ 200 OK (请求成功)



+ 302 Found:请求的资源被暂时的移动到了由Location头部指定的URL上
+ 304 Not Modified:说明无需再次传输请求的内容,也就是说可以使用缓存的内容



+ 400 Bad Request :由于语法无效,服务器无法理解该请求
+ 401 Unauthorized:由于缺乏目标资源要求的身份验证凭证
+ 403 Forbidden :服务器端有能力处理该请求,但是拒绝授权访问
+ 404 Not Found:服务器端无法找到所请求的资源
+ 405 Method Not Allowed:服务器禁止了使用当前HTTP方法的请求
+ 406 Not Acceptable: 服务器端无法提供与Accept-Charset以及Accept-Language指定的值相匹配的响应、
+ 408 Request Timeout :服务器想要将没有在使用的连接关闭
    - 一些服务器会在空闲连接上发送此消息,即便实在客户端没有发送任何请求的情况下

-

+ 500 Internal Server Error : 所请求的服务器遇到意外的情况并阻止其执行请求
+ 501 Not Implemented:请求的方法不被服务器支持,因此无法被处理
+ 502 Bad Gateway:作为网关或代理角色的服务器,从上游服务器中接收到的响应是无效的
+ 503 ServerUnavailable：服务器尚未处于可以接受请求的状态
    - 通常造成这种情况的原因是由于服务器停机维护或者已超载

#### From 表单
action ：请求的url

method:请求方法(GET,POST)

enctype:POST请求时,请求体的编码方式

+ application/x-www-form-urlencoded(默认值)
    - 用&分隔参数，用=分割键和值,字符用URL编码方式进行编码

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731314716314-fb971c2a-954d-4d11-9f66-4aeb32e488fc.png)

+ multipart/from-data
    - 文件上传时必须使用这种编码方式 

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731315019862-1c160729-5c52-40d1-866e-c565d01355c6.png)

##### multipart/from-data
+ RFC1521
+ 请求头
+ Content-Type:multipart/form-data;boundary=XXX

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731336864295-9642d54e-4f27-498b-a1fe-a2b163a0dd65.png)

#### 跨域	-Cookie-Session
##### 跨域
浏览器有个同源策略(Same-Origin-Policy)

他规定了:默认情况下,AJAX请求只能发送给同源的URL

同源是指三个相同: 协议 域名 端口

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731391681822-f0c0f608-dc5f-47cc-af01-348303921f16.png)

img,script,link,iframe,video,audio等标签不受同源策略的约束 

通过CORS(Cross-Origin- Resource Sharing) 跨域资源共享解决跨域问题

CORS的实现须要客户端和服务器同时支持

+ 客户端
    - 所有的浏览器都支持(IE10版本以上)
+ 服务器
    - 需要返回相应的相应头(比如Access-Control-Allow-Origin)
    - 告知浏览器这是一个允许跨域访的请求

##### cookie
在客户端(浏览器)存储一些数据,存储到本地磁盘(硬盘)

服务器可以返回Cookie交给客户端去存储

##### session
在服务器存储一些数据,存储到内存中

### 代理服务器


+ proxy Server 特点
    - 本身不生产内容
    - 处于中间位置转发上下游的请求和响应
    - 面向下游的客户端:他是服务器
    - 面向上游的服务器:他是客户端

 

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731424764400-f7cd2333-67d3-4903-b925-006284564a68.png)

#### 正向代理 - 反向代理
正向代理:代理的对象是客户端

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731425260330-0c2dc437-46a1-4f58-9b12-8e6fa5aa6019.png)

反向代理:代理的对象是服务器

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731425269526-4a6f0948-4811-4bf2-a44b-fa45673a033a.png)

##### 正向代理作用
+ 隐藏客户端身份
+ 绕过防火墙(突破访问限制)
+ internet访问控制
+ 数据过滤等  
+ 免费正向代理
+ [https://ip.jiangxianli.com/](https://ip.jiangxianli.com/)
+ [https://www.kuaidaili.com/free/inha/](https://www.kuaidaili.com/free/inha/)
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731425358370-a9bb373d-c60e-4d74-8b2b-8748d86f9662.png)

##### 反向代理最用
+ 隐藏服务器身份
+ 安全防护
+ 负载均衡

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731425836655-2b2c2263-49ae-447e-a7bc-6e558cb870d2.png)

##### 抓包工具
Fiddler Charles 等抓包工具的原理:在客户端启动了正向代理服务器

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731426076052-d763f325-9bb1-4e56-b93a-5cae4edf118f.png)

Wireshark的原理是:通过底层驱动,拦截网卡上流过的数据

##### 代理服务器- 相关的头部字段
Via:追加经过的每一台代理服务器的主机名(或域名)

X-Forwarded-For:追加请求方的IP地址

X-Real-IP:客户端的请求IP地址

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731426231572-bd2dbc37-b372-40b9-9d7e-997a69add25a.png)![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731426628632-5b67a48a-cf35-4cf4-9e1d-dd35b6d5b460.png)

### CDN
+ CDN(Content Delivery Network或Content Distribution Network),译为:内容分发网络
+ 利用最靠近每位用户的服务器
+ 更快更可靠地将音乐,图片,视频等资源文件(一般是静态资源)传递给用户

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731426738049-619ef3ee-3ab9-4c08-a6cc-34a6e0c3064c.png)

##### 使用CND前后
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731426760843-c15e0c60-f14d-45e3-80ad-426f0c0a638a.png)

CDN运营商在全国,全球的各大枢纽城市建立了机房

部署了大量拥有高存储高带宽的节点,构建了一个跨运营商,跨地域的专用网络、

内容所有者想CDN运营商支付费用,CDN将其内容交付给最终用户

##### 使用CDN之前
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731426915057-b107d99e-fac4-43e2-be2b-0216106cc1c7.png)

##### 使用CDN之后
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731427023238-a2358c0a-ee8f-486f-a53c-254c7f14e49c.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731427213592-44eafe22-400a-4b74-9208-be0449b6573d.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731427273933-0d51bd7e-b39e-4e26-8320-bacbf8e6cc9b.png)

##### 前端CDN地址
[BootCDN - Bootstrap 中文网开源项目免费 CDN 加速服务 铂特优选](https://www.bootcdn.cn/)

# 网络 安全
## 网络通信中面临的四种安全威胁
1. 被动攻击
+ 截获 :窃听了通信内容
3. 主动攻击
+ 中断 :中断网络通信
+ 篡改 ;篡改通信内容
+ 伪造 :伪造通信内容

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731563018305-16934980-d661-4636-a53f-a15edc373072.png)

## 网络层攻击 - ARP欺骗
+ ARP欺骗(ARP spoofing),又称ARP毒化(ARP poisoning),ARP病毒,ARP攻击
+ ARP欺骗可以造成的效果
+ 可让攻击者获取局域网上的数据包甚至可篡改数据包
+ 可让网络上特定电脑之间无法正常通信(例如 网络执法官 这样的软件)
+ 让送至特定ip地址的流量被错误送到攻击者所取代的地方

### 步骤举例
+ 假设主机C是攻击者,主机A,B是被攻击者
+ C只要收到过A,B发送的ARP请求,就会拥有A,B的IP,MAC地址,就可以进行欺骗活动
+ C发送一个ARP响应给B,吧相应包里的源IP设为A的ip地址，源MAC设为C的MAC地址
+ B收到ARP响应后,更新他的ARP表，把A的Mac地址(ip_A,MAC_A)改为(IP_A,MAC_C)
+ 当B要发送数据包给A时,他会根据ARP不熬来封装数据包的头部,把目标MAC地址设为MAC_C,而非MAC_A
+ 当交换机收到B发送给A的数据包时,根据此包的目标MAC地址(MAC_C)而把数据包转发给C
+ C收到数据包后,可以把他存取来后在发送给A,达到窃听效果,C也可以篡改数据后发送数据包给A

### ARP欺骗-防护
1. 静态ARP
2. DHCP Snooping
3. 网络设备可借由DHCP保留网络上各电脑的MAC地址,在伪造的ARP数据包发出时即可侦测到
4. 利用一些软件监听ARP的不正常变动

## DOS DDOS
+ DoS攻击(拒绝服务攻击,Denial-of-Service attack)
    - 使目标电脑的网络或系统资源耗尽,使服务暂时中断或停止,导致其正常用户无法访问
+ DDOS攻击(分布式拒绝服务攻击,Distributed Denial-of-Service attack)
    - 黑客使用网络上两个或以上被攻陷的电脑作为"僵尸" 向特定的目标发起Dos攻击
+ DOS攻击分为2大类
    - 带宽消耗性:UDP洪水攻击 ICMP洪水攻击 等
    - 资源消耗性:SYN洪水攻击,LAND攻击 等

### SYN洪水攻击
+ SYN洪水攻击(SYN flooding attack)
    - 攻击者发送一系列的SYN请求到目标,然后让目标因收不到ACK(第三次握手)而等待,消耗资源
+ 攻击方法
    - 跳过发送最后的ACK信息
    - 修改源IP地址,让目标送SYN-ACK到伪造的ip地址,因此目标永不可能收到ACK(第三次握手)
+ 防护
    - RFC 4987

### LAND攻击
+ LAND攻击(局域网拒绝服务攻击,Local Area Network Denial attack)
    - 通过持续发送相同源地址和目标地址的欺骗数据包,使目标试图与自己建立连接,小号系统资源直至崩溃
+ 有些系统存在设计上的缺陷,润许设备接受并响应来自网络,却宣称来自于设备自身的数据包,导致循环应答



+ 防护
+ 大多数防火墙都能拦截类似的攻击包,以保护系统
+ 部分操作系统通过发布安全补丁修复了这一漏洞
+ 路由器应同时配置上行与下行筛选器,屏蔽所有源地址与目标地址相同的数据包

## DOS DDOS防御
+ 防御方式通常为:入侵检测, 流量过滤，多重验证
    - 堵塞网络带宽的流量将被过滤,而正常的流量可正常通过
+ 防火墙
    - 防火墙可以设置规则,如允许或拒绝特定通讯协议,端口或IP地址
    - 当攻击从少数不正常的ip地址发出时,可以简单的使用拒绝规则阻止一切从攻击源IP发出的通信
    - 复杂攻击难以用简单规则来阻止,例如80端口遭受攻击时不可能拒绝端口所有通信,因为同时会阻止合法流量
    - 防火墙可能处于网络架构中过后的位置,路由器可能在恶意流量达到防火墙前即被攻击影响
+ 交换机:大多数交换机有一定的速度限制和访问控制能力
+ 路由器:和交换机类似,路由器也有一定的速度限制和访问控制能力
+ 黑洞引导
    - 将所有受攻击计算机的通信全部发送至一个黑洞(空接口或不存在的计算地址) 或者有足够 能力处理洪流的网络设备,以避免网络收到较大影响
+ 流量清洗
    - 当流量被送到DDos防护清晰中心时,通过采用抗DDOS软件处理,将正常流量和恶意流量区分开
    - 正常流量则回注回客户网站 

### 应用层-DNS劫持
+ DNS劫持,又称为域名劫持
    - 攻击者篡改了某个域名的解析结果,使得指向该域名的IP变成了另一IP
    - 导致对响应网站的访问被劫持到另一个不可达的或者假冒的网址
    - 从而实现非法窃取用户信息或者破坏正常网站服务的目的
+ 为防止DNS劫持,可以考虑使用更靠谱的DNS服务器,比如:114.114.114.114
+ 谷歌:8.8.8.8      8.8.4.4
+ 微软:4.2.2.1	4.2.2.2
+ 百度:180.76.76.76
+ 阿里:223.5.5.5	223.6.6.6



+ HTTP劫持:对HTTP数据包进拦截处理,比如插入js代码

# HTTP协议的安全问题
+ HTTP协议默认是采用铭文传输的,因此会有很大的安全隐患
    - 常见的提高安全性的方法是:对通信内容进行加密后,在进行传输
+ 常见的加密方式有
    - 不可逆
        * 单向单列函数:MD5 SHA等
    - 可逆
        * 对称加密:DES  3DES  AES等
        * 非对称加密: RSA等
    - 其他
        * 混合密码系统
        * 数字签名
        * 整数

### 常用单词
encrypt :加密

decrypt:解密

plaintext:明文

ciphertext:密文

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731595671804-7b4dd7be-ff69-488c-801f-2073adc91fb4.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731595684486-ca30c827-1254-43d0-a301-d6b9585a72ed.png)

### 防止窃听进行加密
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731595990195-612672f4-5368-43f6-8002-597b3edc1752.png)

### 单向散列函数 (One-way hash function)
单向散列函数,可以根据消息内容计算出散列值

散列值的长度和消息的长度无关,无论消息是1bit,10M,100G,单向散列函数都会计算出固定长度的散列值

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731597977242-183812e8-cd82-4196-8e58-0940e639c1c9.png)

#### 特点
+ 根据任意长度的信息,计算出固定长度的散列值
+ 计算速度快,能快速计算出散列值
+ 消息不同,散列值也不同
+ 具备单向性

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731598075048-1323f2d6-70b2-4310-a8de-f6c7d7e5d123.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731598143386-e971d906-8ce9-4afe-9fae-00030d5cff15.png)



#### 称呼
+ 单项散列函数,也被称为
    - 消息摘要函数(message digest function)
    - 哈希函数(hash function)
+ 输出的散列值,也被称为
    - 消息摘要(message digest)
    - 指纹(fingerprint)

#### 常见的几种三项单列函数
+ MD4 ,MD5
    - 产生128bit的散列值,MD就是Message Digest的缩写,目前已经不安全
+ SHA -1
    - 产生160bit的散列值,目前已经不安全
+ SHA-2
    - SHA-256,SHA-384,SHA-512,散列值长度分别是256bit,384bit,512bit
+ SHA-3
    - 全新标准

#### 如何防止数据被篡改
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731599001946-24a2bb01-2481-4fe1-9c7e-597f4971adde.png)



![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731599095866-89972365-119e-4c8e-bd4c-d0b2465622c1.png)

使散列值进行对比

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731599071502-3b2ac1ae-12bb-4a0a-8426-9b6d068f3eb6.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731599227401-ff8efdc3-24ec-47d7-a728-87a4eeecb016.png)

应用密码加密

### ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731600046436-0f82f944-e516-4cd6-a63c-9f82dfedd6ef.png)加密解密
**加密算法+密钥**

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731726097568-a0f9968e-a0d2-4c08-bd93-2b4428d5bdaf.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731726285876-6b213c5c-185e-49ec-886b-41c72706abd3.png)

#### 对称加密(Symmetric Cryptography)
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731726315817-2b5a387d-d03b-43c5-b4be-bd8d8ed77fed.png)

+ 在对称加密中,加密.解密时使用的是同一个密钥
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731726462247-884ffd08-cf17-4ddf-8a7c-b867f7b22a95.png)
+ 常见的对称加密算法有
+ DES
+ 3DES
+ AES

##### DES(Data Encryption Standard)
Data Encryption Standard:数据加密标准

**加密**

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731726688600-7de845e4-0fc5-4d50-a7fb-9ec984c8f668.png)

**解密**

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731726720863-e1ed6b26-8407-427b-965c-afaebdcc1b4e.png)

+ DES是一种将64bit明文加密成64bit密文的对称加密算法,密钥长度是56bit
+ 规格上来说,密钥长度是64bit,但每隔7bit会设置一个用于错误检查的bit,因此密钥长度实际上是56bit
+ 由于DES每次只能加密64bit的数据,遇到比较大的数据,需要对DES加密进行迭代(反复)
+ 目前已经可以在短时间内被破解,所以不建议使用

##### 3DES(Triple Data Encryption Standard)
+ 3DES 将DES重复3次所得到的一种密码算法,也叫做3重DES
    - 单词DES并不是进行三次DES加密(加密 => 加密 => 加密 )
    - 而是加密(Ecnryption) 	=> 解密(Decryption) => 加密(Ecnryption) 的过程
    - 目前还被一些银行等机构使用,但处理速度不高,安全行逐渐暴露出问题
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731834568142-875a61ca-63a7-4817-954b-f4ab5c1ad666.png)
    - 三个密钥都是不同的,也称为DES-EDE3
    - 如果所有的密钥都是用同一个,则结果与普通的SED是等价的
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731835692903-33a4d406-8b46-4011-b3ed-fb957dc0a8fa.png)
    - 如果密钥1密钥2相同 密钥2不同,称为DES-EDE2
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731835761603-ce2328bf-7d2b-4dd0-bdd2-f05b82480c68.png)

##### AES (Advancend Encryption Standard）
+ 取代DES称为新标准的一种对称加密算法,又称Rijndael加密法
+ AES的密钥长度有128,192,256bit三种
+  目前AES,已经逐步取代DES ,3DES,成为首选的对称加密算法
+ 一般来说,我们也不应该去使用任何自制的密码算法,而是应该使用AES
    - 他经过了全世界密码学家所进行的高品质验证工作
+ 

#### 密钥安全
对称加密(简单 不安全 加解密速度快)

非对称加密 (复杂 安全 加解密速度慢)

在使用对称加密时,会遇到密钥如何配送

+ 如果Alice将使用对称加密过的消息发给Bob
    - 只有将密钥发送给Bob,Bob才能完成解密
    - 在发送密钥过程中
        * 可能会被Eve窃取密钥
        * 最后Eve也能完成解密

#### 密钥配送
+ 事先共享密钥(私下共享)
+ 密钥分配中心(key Distribution Center 简称KDC)
+ Diffie-Hellman密钥交换
+ 非对称加密 (复杂 安全 加解密速度慢)

#### 密钥配送问题
+ 由消息的接收者,生成一对公钥,私钥
+ 将公钥发给消息的发送者
+ 消息的发送者使用公钥加密消息
+ 非对称加密的加密解密速度比对称加密要慢

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731852354905-a709fe53-e265-40f9-b7f9-43f8c5c99c65.png)

#### 
#### 非对称加密(Asymmentric Cryptography)
+ 在非对称加密中,密钥分为加密密钥,解密密钥2种,他们并不是同一个密钥
+ 加密密钥:一般是公开的,因此该密钥称为公钥(public key)
    - 因此	，非对称加密也被称为公钥加密(public-key Cryptography)
+ 解密密钥:由消息接收者自己保管的,不能公开,因此也称为私钥(private key)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731846271451-7881365a-57fa-49bb-8275-34a2b003fb1e.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731849636090-afbfa1e2-54ef-4523-81b4-d0977fd14b56.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731726369180-493547f2-0b8a-4bf8-9bd2-58e96efed52d.png)

##### RSA
+ 目前使用最广泛的非对称加密算法是RSA
+ RSA的名字,由他的三位开发者,即Ron Rivest, Aid Shamir ,Leonard Adleman的姓氏首字母组成

  

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731840869535-43e42254-4ae5-4650-bf1a-0ae11fbd41c4.png)

#### 公钥 私钥
+ 公钥和私钥是一一对应的,不能单独生成
    - 一对公钥和私钥统称为密钥对(key pair)
+ 由公钥加密的密文,必须使用与该公钥对应的私钥才能解密
+ 有私钥加密的密文,必须使用与该私钥对应的公钥才能解密

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731849731394-65131cea-514b-4047-a8a7-4fddf52e84a7.png)

##### 


#### 混合密码系统(Hybrid Cryptosystem)
+ 对称加密的缺点
    - 不能很好地解决密钥配送问题(密钥会被窃听)
+ 非对称加密的缺点
    - 加密解密速度比较慢
+ 混合密码系统:是将对称加密和非崔很加密的优势相结合的方法
    - ·解决了非对称加密加密速度慢的问题
    - 并通过非对称加密解决了对称加密的密钥配送问题



+ 网络上的密码通信所用的SSL/TLS都运用了混合密码系统

#### 混合密码 
##### 加密
+ 会话密钥(session key)
    - 为本次通信随机生成的临时密钥
    - 作为对称加密的密钥,用于加密消息,提高速度
+ 加密步骤(发送消息)
    - 首先,消息发送者要拥有消息接收者的公钥
    - 生成会话密钥,作为对称加密的密钥,加密消息
    - 用消息接收者的公钥,加密绘画密钥
    - 将前2步生成的加密结果,一并发给消息接收者
+ 发送出去的内容包括
    - 用会话密钥加密的消息(加密方式:对称加密)
    - 用公钥加密的会话密钥(加密方式:非对称加密)
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731855852994-55c8f630-7401-44ce-9a0d-bd21a24513aa.png)

##### 解密
收到消息

+ 消息接收者用自己的私钥解密出会话密钥
+ 再用第1步解密出来的会话密钥,解密消息

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731858875963-d1b909bd-7d78-405b-8ee3-a6fb5e6a3cdb.png)

##### 混合密码-加密解密流程
+ Alice >>>Bob
+ 发送过程(加密方式)
    -  Bob生成一对公钥,私钥
    - Bob把公钥共享给Alice
    - Alice随机生成一个会话密钥(临时密钥)
    - Alice用会话密钥加密需要发送的消息(使用的是对称加密)
    - Alice用Bob的公钥加密会话密钥(使用对称加密)
    - Akice把四4步骤和第5步骤的加密结果,一并发送给Bob
+ 接收过程(解密过程)
    - Bob利用自己的私钥解密会话密钥(使用的是i非对称加密算法进行解密)
    - Bob利用会话密钥解密发送过来的消息(使用的是对称加密算法进行解密)

插件

openssl用于生成公钥私钥

### 数字签名
+ 用与解决当前消息的真实性防止篡改,伪装,否认。
    - 签名内容验证失败,代表内容被篡改
    - 数字签名的最用仅仅是为了能够是被内容有没有被篡改
    - **确认消息的完整性**
    - **识别消息是否被篡改**
    - **防止消息发送人否认	**
+ 在数字签名技术中,有一下两种行为
    - 生成签名
        * 有消息的发送者完成,通过'签名密钥'生成
    - 验证签名
        * 有消息的接收者完成,通过''验证密钥'验证
    - 如何能保证这个签名是消息发送者自己签的?
        * 用消息发送者的私钥进行签名

#### 过程 
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731930895019-45da9a6a-bc79-462a-91d7-cd1516d4a020.png)

#### 进阶版
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731933715389-86ea3d72-6d59-476d-9279-6d351356f22c.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731934837517-baa1bf10-463c-4a8b-8014-a7654629f67f.png)

在非对称加密中,任何人都可以使用公钥进行加密

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731936516063-1583c393-7a69-4f58-851f-27de8c47a82b.png)

在数字签名中任何人都可以使用公钥验证签名

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731936565747-426086ba-cd36-4277-962d-cfd2776cf5d9.png)

数字签名,其实就是将非对称加密反过来使用

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731936618933-13217027-07af-4230-b924-8b2c0519325e.png)

+ 既然是加密,那肯定是不希望别人知道我的消息,所以只有我才能解密
    - 公钥负责加密,私钥负责解密
+ 既然是签名,那肯定是不希望有人冒充我发消息,所以只有我才能签名
    - 私钥负责签名,公钥负责验签

### 公钥的合法性
如果遭遇了中间人攻击,那么

公钥可能是伪造的

使用证书来验证公钥的合法性



![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731937318663-27feb37f-0b54-413d-8756-f1b5dd3ea554.png)

### 证书
#### 证书Certificate
由权威机构认证的证书

+ 密码学中的证书,全称公钥证书(Public-key Certificate PKC),跟驾驶证类似
    - 里面由姓名,邮箱等个人信息,以及此人的公钥
    - 并由认证机构(Certificate Autthority ,CA)施加数字签名
+ CA就是能够认定'公钥确实属于此人'并能够生成数字签名的个人或者组织
    - 有国际性组织,政府设立的组织
    - 有通过提供认证服务来盈利的企业
    - 个人也可以成立认证机构

#### 使用
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731942042624-7927359e-7669-4027-b102-c4c4d624581f.png)

#### 注册下载
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731942792140-1ac4d895-e7a9-44dd-9263-a84f9ccac4da.png)

#### 查看windows已经信任的证书
+ windows+r =>mmc
+ 文件 => 添加/删除管理单元
+ 证书=> 添加=> 我的用户账户=>完成=>确定
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731943618105-9d8dc6f0-ed06-41ba-837f-404ed5abcfc8.png)

# HTTPS
## HTTPS
+ (HyperText Transfer Protocol Secure)超文本传输安全协议
    - 常称为HTTP over TLS ,HTTP over SSL HTTP Secure
    - 由网景公司于1994年首次提出
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731986218483-8df13a34-d4f1-4f7d-914f-e0e72f989a22.png)
+ HTTPS的默认端口是443(HTTP是80)

## SSL/TLS	
+ HTTPS是在HTTP的基础上使用SSL/TLS来加密报文,对窃听和中间人攻击提供合理的防护

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731987495081-cbd18a42-111f-4ea0-81b7-b67491957a59.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731987511381-fd85d932-580e-4f39-aeff-b28ab6c3913b.png)

+ SSL/TLS也可以用在其他协议上,比如
    - FTP->FTPS
    - SMTP-> SMTPS
+ TLS(Transport Layer Security),译为:传输层安全性协议
    - 前身是SSL(Secure Socker Layer),译为:安全套接层
+ 历史版本信息
    - SSL 1.0:因存在严重的安全漏洞,从未公开过
    - SSL 2.0:1995年,已与2011年弃用(RFC 6176)
    - SSL 3.0:1996年,已于2015年弃用(RFC7568)
    - TLS 1.0:1999年(RFC2246)
    - TLS 1.1:2006年(RFC4346)
    - TLS 1.2:2008年(RFC5246)
    - TLS 1.3:2018年(RFC8446)

### SSL/TLS 工作在那一层
### SSL/TLS工作在应用层和传输层之间![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731988226435-33cdd155-b476-44a5-9b35-4629a44a77ee.png)OpenSSL
+ OpenSSL是SSL/TLS协议的开源实现,始于1998年,支持windows,MAC ,Linux等平台
    - Linux Mac一般自带OpenSSL
    - Windows下载安装OpenSSL:[OpenSSL](https://slproweb.com/products/Win32OpenSSL.html)
+ 常用命令
    - 生成私钥 openssl genrsa -out mj.key
    - 生成公钥 openssl rsa -in mj.key -pubout -out mj.pem



可以使用OpenSSL构建一套属于自己的CA,自己给自己颁发证书,成为'自签名整数'

## HTTPS的成本
+ 证书的费用
+ 加解密计算
+ 降低了访问速度
+ 有些企业的做法是,包含敏感数据的请求才使用HTTPS,其他保持使用HTTP

## HTTPS的通信过程
+ 分为三大阶段
    - TCP三次握手
    - TLS的连接
    - HTTP请求和响应  
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731990135140-7e6554b4-2b9e-4fc7-937d-0a30c162f741.png)

### TLS 1.2的连接
+ 大概是由10大步骤
+ 图片中省略了中间产生的一些ACK确认

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731991098816-1004ee8f-eda1-45b9-9e2b-12b835d9ab48.png)

1. Client Hello
    1. TLS的版本号
    2. 支持的加密组件(Cipher Suite)列表
        1. 加密组件是指所使用的加密算法及密钥长度等
    3. 一个随机数(Client Random)
2. Server Hello
    1. TLS的版本号
    2. 选择的加密套件
        1. 是从接收到的客户端加密组件列表中挑选出来的
    3. 一个随机数(Client Random)
3. Certificate(证书)
    1. 服务器把自己的公钥证书(被CA签名过的)发送给客户端
    2. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731994077152-031fd21a-1fa7-49c3-86d6-d96e8987b75f.png)
4. Server Key Exchange
    1. 用以实现ECDHE算法的其中一个参数(Server  Params)
        1. ECDHE是一种密钥交换算法
        2. 为了防止伪造,Server Params经过了服务器私钥签名
    2. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731995368904-6b0a25c1-c151-4596-9127-028fdae9de27.png)
5. Server Hello Done
    1. 告诉客户端:协商部分结束了
    2. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731995596656-13ec4391-3a3b-4d13-bf71-a74861bdee30.png)
    3. 目前为止客户端和服务端之间通过明文共享了
        1. Client Random Server Random Server Params
        2. 而且,客户端也已经拿到了服务器的公钥证书,接下来,客户端会验证证书的真是有效性
6. Client Key Exchange
    1. 用以实现ECDHE算法的另一个参数(Client Params)
    2. 目前为止,客户端和服务器都拥有了ECDHE算法需要的两个参 :Server Param Client Param
    3. 客户端,服务器都可以使用ECDHE算法
        1. 根据Server Param Client Param计算出一个新的随机密钥穿串:Pre-master  secret
        2. 然后结合Client Random Server Random  Pre-master secret 生成一个主密钥
        3. 然后利用主密钥衍生出其他密钥:客户端发送用的会话密钥,服务器发送用的会话密钥等
7. Change Cipher Spec
    1. 告知服务器:之后的通信会采用计算出来的会话密钥进行加密
    2. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1731996412145-8445b304-5ea7-49d9-9866-633a6586658d.png)
8. Finished
    1. 包含连接至今全部报文的整体校验值(摘要),加密之后发送给服务器
    2. 这次握手协商是否成功,要以服务是否能够正确解密该博文作为判断标准
9. Change Cipher Spec
10. Finished
    1. 和7和8一样用来验证服务端的信息客户端能否解密
    2. 到此为止客户端服务器都验证加密解密没问题,握手正式结束
    3. 后面开始传输加密的HTTP请求和响应

### HTTP协议的不足(HTTP1.1)
+ 同一时间,一个连接只能对应一个请求
    -   针对同一个域名,大多数浏览器允许同时最多6个并发连接
+ 只允许客户端主动发起请求
    - 一个请求只能对应一个响应
+ 同一个会话的多次请求中,头信息会被重复传输
    - 通常会给每个传输添加500~800字节的开销
    - 如果使用cookie,增加的开销有时会达到上千字节

### SPDY
+ SPDY(speedy的缩写),是基于TCP的应用层协议,他强制要求使用SSL/TLS
    - 2009年11月,google宣布将SPDY作为提高网络速度的内部项目
+ SPDY与HTTP的关系
    - SPDY并不用于取代HTTP，他只是修改了HTTP请求和响应的传方式
    - 只需增加一个SPDY层,现有的所有服务端应用均不用做任何修改
    - SPDY是HTTP/2的前身
    - 2015年9月,Google宣布一处对SPDY的支持,拥抱HTTP/2
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732023413835-383d5c98-3ca3-4450-baeb-45604213599d.png)

# HTTP2
+ HTTP/2,于2015年5月RFC 7540正式发表
    - HTTP1.1 和HTTP2速度对比
    - www.http2demo.io
    - http2.akamai.com/demo
+ HTTP2的底层传输做了很多的改进和优化,但在语义上完全与HTTP1.1兼容
    - 比如请求方法(如GET POST)，Status Code ,各种Headers等都没有改变
    - 因此,要想升级到HTTP2
        * 开发者不需要修改任何代码
        * 只需要升级服务器配置,升级浏览器

### HTTP2 二进制格式
HTTP2采用二进制格式传输数据,而非HTTP1.1的文本格式

微软禁止格式在协议和解析和优化扩展上带来更多的优势和可能

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732028432555-361968c4-5321-454b-aa20-f10ced10228f.png)

#### 基本概念
+ 数据流:已建立的连接内的双向字节流,可以承载一条或多条消息
    - 所有通信都在一个TCP连接上完成,此连接可以承载任意数量的双向数据流
+ 消息:与逻辑HTTP请求或响应消息对应,由一系列帧组成
+ 帧:HTTP2通信的最小单位,每个帧都包含帧头(会标识出当前帧所属的数据流)
    - 来自不同数据流的帧可以交错发送,然后根据每个帧头的数据流标识重新组装

#### ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732254044678-471dd204-6af3-4e1e-beda-f7c0da58c6d9.png) HTTP2的一些基本概念
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732254492903-cf4c765b-8407-4d66-8cdd-23fc3eb9eaf3.png)

#### HTTP2-多路复用
+ 客户端和服务端可以将HTTP消息分解为互不依赖的帧,然后交错发送,最后再另一端把他们重新组装起来
+ 并行交错地发送多个请求,请求之间互不影响
+ 并行交错低发送多个响应,响应之间互不干扰
+ 使用一个连接并行发送多个请求和响应
+ 不必再为绕过HTTP1.1限制而做很多工作
    - 如 image Sprites 合并CSS/JS 内嵌CSS/JS/Base64图片,域名分片等
    -  

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732254805620-3667dcfa-71ef-4c1c-8e05-94fa31caf107.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732255611278-d4b94418-d7f7-4587-bd3f-8948353cdda6.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732255751790-cf716618-f4aa-42b9-b862-0c0a4ef8599e.png)

#### HTTP2-优先级
+ HTTP2标准允许每个数据流都有一个关联的权重和依赖关系
    - 可以向每个数据流分配一个介于1至256之间的整数
    - 每个数据流与其他数据流之间可以存在显示依赖关系
+ 客户端可以构建和传递'优先级树',表明他倾向于如何接收响应
+ 服务器可以使用此消息通过控制CPU，内存和其他资源的分配设定数据流处理的优先级
    - 在资源数据可用之后,确保将高优先级响应以最优方式传输至客户端
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732256277929-bbacff97-f813-440d-8589-d9cabd2bc67c.png)
+ 尽可能先给父数据流分配资源
+ 同级数据流(共享相同父项),应按其权重比例分配资源
    1.   A,B依赖与隐式"根数据流",A获得的资源比例是12/16,B获得的资源比例是4/16
    2. D依赖于根数据流,C依赖于D，D应先于C获得完整资源分配
    3. D应先与C获取完整资源分配,C应咸鱼A和B获得完整资源分配,B获得的资源是A所获取的1/3
    4. D应先与E和C获取完整资源分配,E和C应先于A和B获得完整资源分配,B获得的资源是A所获取的1/3

#### HTTP2-头部压缩
+ HTTP2使用HPACK也锁请求头和响应头
    - 可以极大减少头部开销,进而提高性能
+ 早期HTTP2和SPDY使用Zlib压缩
    - 可以将所传输头部的大小减少85%~88%
    - 后续呗攻击导致会话劫持,后被更安全的HPACK代替

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732257092811-19d91afc-429d-45c0-a423-b3bf990764ee.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732263741374-4cbb1d09-dfbb-474e-b070-2b999171cba3.png) 

#### HTTP2-服务端推送(Server Push)
+ 服务器可以对一个客户端请求发送多个响应
    - 除了多最初请求的相应外,服务器还可以向客户端 推送额外资源,而无需客户端额外明确地请求
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732257546377-a83478c6-be17-4760-9241-0f06b5e99a58.png)

### HTTP2 问题
#### HTTP2 问题-队头堵塞(head of line blocking)
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732257826846-2c4ea256-0aea-4b20-84f3-2a98abe5f46f.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732257838550-70116a4d-462d-4283-8460-0958ea4ee5fd.png)![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732257869173-f985da8b-32c6-46db-bb08-00d2e10cf88d.png)

#### HTTP2问题 -握手延迟
+ RTT（Round Trip Time）:往返时延,可以简单理解为通信一来一回的时间

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732258003528-2e8fdaad-dd79-4df8-822e-cef7ca830ea3.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732258180681-b2124b55-ebd0-453e-92c5-4379c054d446.png)

# HTTP3
+ Google觉得HTTP2仍然不够快,于是就有了HTTP3
    - HTTP3由Google开发,弃用TCP协议,改为使用基于UDP协议的QUIC协议实现
    - QUIC(Quic UDP Internet Connections),译为:快速UDP网络连接,由Google开发,在2013年实现
    - 与2018年从HTTP-over-QUIC改为HTTP3
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732258338127-672e05da-510c-451d-a1f5-4f4f60c104d0.png)

#### HTTP3  特性-连接迁移
+ TCP基于4要素(源ip 源端口 目标ip 目标端口)
    - 切换网络时至少会有一个要素发生变化,导致连接发生变化 
    - 当连接发生变化时,如果还使用原来的TCP连接,则会导致连接失败,就得等原来的连接超时后重新建立连接
    - 所以我们有时候发现切换到一个新网络时,即使新网络状态良好,但内容还是需要加载很久
    - 如果实现的好,当检测到网络变化时立刻建立新的TCP连接,即使这样,建立新的连接还是需要几百毫秒的时间
+ QUIC的连接不受4要素的影响,当4要素发生变化时,原连接依然维持
    - QUIC连接不以4要素作为标识,而是使用一组Connection ID(连接ID)来标识一个连接
    - 即使IP或端口发生变化,只要Connection ID没有变化,那么连接依然可以维持
    - 比如	
        * 当设备连接到wifi时,将进行中的下载从蜂窝网络连接转换到更快速的wifi连接
        * 当wifi连接不再可用时,将连接转移到蜂窝网络连接 

#### HTTP3的问题-操作系统内核,CPU内核
+ 据Google和Facebook称,与基于TLS的HTTP2相比,他们大规模部署的QUIC需要进2倍的cpu使用量
    - Linux内核的UDP部分没有得到像TCP那样的优化,应为传统上没有使用UDP进行如此告诉的信息传输
+ TCP和TLS由硬件加速,而这对于UDP很罕见,对于QUIC则基本不存在

# HTTP对比WebSocket
+ HTTP请求的特点:通信只能由客户端发起,所以,早期很多网站为了实现推送技术,所用的技术都是轮询
+ 轮询是值由浏览器每隔一段时间(如每秒)像服务器发出HTTP请求,然后服务器返回最新的数据给客户端
+ 为了能更好的节省服务器资源和带宽,并且能够实时地进行通讯,HTML5规范中出现了WebSocket协议
+ WebSocket和HTTP属于平级关系,都是应用层的协议
    - 其实TCP本身是支持全双工通信的(客户端,服务器均可主动发消息给对方)
    - 只是HTTP的"请求-应答模式"限制了TCP的能力  
+ WebSocket使用80(sw://),443(wss://)端口,可以绕过大多数防火墙的限制
    - ws://example.com/wsapi
    - wss://secure.example.com/wsapi
+ 与HTTP不同的是,WebSocket需要先建立连接
    - 这就使得WebSocket称为一种有状态的协议,之后通信时可以省略部分状态信息
    - 而HTTP请求可能需要在每个请求都额外携带状态信息(如身份认证等)
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732265645651-ba845296-8ebb-4643-bccb-c48faa95ba36.png)

##  WebSocket
+ websocket,是基于TCP的支持全双工通信的应用层协议
    - 在2011年由IETF标准化为RFC 6455,后由RFC 7936补充规范
    - 客户端,服务器,任何一方都可以主动发消息给对方
+ Websocket的应用场景很多
    - 社交订阅,股票基金报价,体育实况更新,多媒体聊天,多玩家游戏等

### 建立连接
+ WebSocket需要借助HTTP协议来建立连接(也叫做握手,Handshake)
    - 有客户端(浏览器)主动发出握手请求需要借助HTTP请求来实现连接
    - Connection 必须设置Upgrade
        * 表示客户端希望连接升级
    - upgrade必须设置websocket
        * 表示希望升级到WebSocket协议
    - Sec-WebSocket-Version
        * 表示支持的WebSocket版本
        * RFC6455要求使用的版本是13
1. Sec-WebSocket-Key是客户端生成的随机字符串,比如例子中的dGh1IHNhbXBsZSBub25jZQ==
2. 服务器接收到客户端的Sec-Web-Socket-Key后,会进行以下操作
    1. Sec-Web-Socket-Key加上一个固定的GUID值(258EAFA5-E914-47DA-95CA-C5ABODC85B1	1)
        1. dGh1IHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5ABODC85B11
    2. 将a的结果进行SHA-1摘要计算
        1. b37a4f2cc0624f1690f64606cf385945b2bec4ea
    3. 将b的结果进行Hex base64编码
        1. s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
    4. 将c的结果作为Sec-WebSocket-Accept响应头的值,返回的客户端
    5. 如此操作,可以尽量避免普通HTTP请求被误认为WebSocket协议
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732345775686-5dad0a21-167f-4597-a6d3-2721e835741c.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732345793576-5f03f5d7-d710-47e9-a1ce-dd25206254a8.png)

##  WebService
+ WebService,译为:Web服务,是一种跨编程语言和跨操作系统平台的远程调用技术标准
+ WebService使用场景举例
    - 天气预报,手机归属地查询,航班信息查询,物流信息查询等
+ WebServe完全可以用普通的Web Api取代(如HTTP+JSON)
    - 现在很多企业的开放平台都是直接采用WebAPI 

### 核心概念  
+ SOAP (simple Object Access Protocol)译为 :简单对象访问协议
    - 很多时候,SOAP=HTTP+XML
    - WebService使用SOAP协议来封装传递数据
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732373629221-cc7d3d5a-6393-4552-8cc1-bf05f9714ba9.png)
+ WSDL(web Services Description Language) 译为Web服务描述语言
    - 一个XML文档,用以描述WebService接口的细节(比如参数，返回值等)
    - 一般在WebService的URL后面跟上?wsdl获取SWDL信息

# RESTful
+ REST全称是REpresentational State Transfer
    - 释为"表现层状态转移"
+ REST是一种互联网软件架构设计风格
    - 定义了一组用于创建Web服务的约束
    - 符合REST架构的Web服务,称为RESTful web服务
+ URL中使用名词(建议用附属形式),不使用动词
    - 推荐/users  /users/6
    - 不推荐/listUsers /getUser？id=6 /user/list /user/get?id=6
+ 使用HTTP的方法表达动作
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732383245308-daf46581-405f-4ffa-afdc-da98a79b93f4.png)
+ 一个资源连接到其他资源,使用子资源的形式
    - GET /users/6/cars/88
    - POST /users/6/cars
+ API版本化
    - xxx.com/v1/users
    - xxxcom/v2/users/66
+ 返回json格式的数据
+ 发生错误时,不要返回200状态码

# HTTPDNS
+ HTTPDNS是基于HTTP协议想DNS服务器发送域名解析请求
    - 替代了基于DNS协议想运营商LocalDNS发起解析请求的传统方式
    - 可以避免Local DNS造成的域名劫持和跨网站访问问题
    - 常用在移动互联网中(比如Android,ios开发中)
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732385371599-372e449a-4357-4c92-adf6-8c7352798900.png)
+ 使用
    - 市面上的现有产品
        * 腾讯云 阿里云
    - 移动端集成相关的SDK即可使用HTTPDNS服务

# FTP
+ FTP(File Transport Protocol) ,译为:文件传输协议,RFC959定义了此规范,是基于TCP的应用层协议
    - 在RFC 1738中有定义,FTP的格式为:ftp://[user[:password]@]host[:port]/url-path
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732387080394-d230266d-3fcf-4a42-a58e-37a34dbdfefa.png)

## FTP - 连接模式
+ FTP有两种连接模式:主动(Active)和被动(Passive)
+ 不管是那种模式,都需要客户端和服务器建立两个连接
    - 1. 控制连接:用于传输状态信息(命令,cmd)
    - 2. 数据连接:用于传输文件和目录信息(data)
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732387373847-70a7f51a-fc9f-4101-9e77-df68230c602e.png)

## FTP - 主动模式
1. 客户端打开一个随机的命令端口
    1. 端口号大于1024,假设为N
    2. 同时连接到服务器的命令端口21
2. 客户端开始监听N+1数据端口
    1. 同时想服务器发送一个Port命令给服务器的命令端口21
    2. 此命令是告诉服务器
        1. 客户端正在监听的数据端口N+1
        2. 并且已准备好从此端口接收数据
3. 服务器发开20号数据端口,并且创建和客户端数据端口(N+1)连接

## 
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732387872668-793abc21-06c9-4313-a51c-3784ebac7935.png)

## FTP - 被动模式
1. 客户端通过两个随机的端口与服务器建立连接
    1. 命令端口N
    2. 数据端口N+1
2. 客户端的命令端口N用于连接服务器的命令端口21
3. 客户端通过命令端口N发送PASV命令给服务器的命令端口21
4. 服务器会打开一个随机的数据端口ip,并告知客户端该端口号ip
5. 客户端数据端口N+1发起与服务器数据端口P的连接

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732387428062-c220d7c6-08d5-4618-ab16-e25fef03e8b7.png)

# 邮件协议
+ 发邮件使用的协议
    - STMP(Simple Mail Transfer Protocol) 译为:简单邮件传输协议
        * 基于TCP,标准RFC5321
        * 服务器默认使用25端口,SSL/TLS使用456端口
+ 收邮件使用的协议
    - POP(Post Office Prococol)译为:邮局协议
        * 基于TCP.最新版是POP3,标准参考RFC 1939
        * 服务器默认使用110端口,SSL/TLS使用995端口
    - IMAP(Internet Message Access Protocol)译为:因特网信息访问协议
        * 基于TCP,最新版是IMAP4,标准参考RFC3521
        * 服务器默认使用143端口,SSL/TLS使用993端口

## 收发邮件的过程
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732389812078-8c0758b3-2935-4b8f-b014-797a0a0bfee4.png)

## POP 与 IMAP
+ POP的特点
    - 客户端连接服务器时,将会从服务器下载所有邮件
        * 可以设置下载完后,立即或一段时间后删除服务器邮件
    - 客户端的操作(比如删除邮件,移动到文件夹)不会跟服务器同步
    - 每个客户都是独立的,都可以获得其自己的电子邮件副本
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732389779366-c1288ca2-fc80-4527-a08f-5b607384fd93.png)
+ IMAP的特点
    - 客户端连接服务器时,获取的是服务器上邮件的基本信息,并不会下载邮件
        * 等打开邮件时,才开始下载邮件
    - 客户端的操作(比如删除邮件,移动到文件夹)会跟服务器同步
    - 所有客户端始终会可看到相同的邮件和相同的文件夹
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732389854707-24bf150a-9024-4f93-8f4c-2fd6854ca7c7.png)



# VPN 
+ VPN (Virtual Private Network),译为:虚拟拟人网络
    - 它可以在公共网络上建立专用网络,进行加密通讯
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732391014239-bf20eed9-6f88-4b61-8372-297f94659059.png)
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732391308262-03a1caf9-76cd-4939-9f43-8a49564c69c9.png)

## VPN - 作用
1. 提高上网的安全性
2. 保护公司内部资料
3. 隐藏上网者的身份
4. 突破网站的地域限制
    1. 有些网站针对不同地区的用户展示不同的内容
5. 突破网络封锁
    1. 应为有GWF的限制,有些网站在国内上不了
    2. Great Firewall of China
    3. 中国长城防火墙

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732391405566-09f6484d-8429-4739-b200-c61b8149cefa.png)

## VPN - 与代理的区别
+ 软件
    - VPN一般需要安装VPN客户端软件
    - 代理不需要安装额外的软件
+ 安全性
    - VPN默认会对数据进行加密
    - 代理默认不会对数据进行加密(数据最终是否加密取决于使用的协议本身)
+ 费用
    - 一般情况下,VPN比代理贵

## VPN - 实现原理
+ VPN的实现原理是:使用了隧道协议(Tunneling Protocol)
+ 常见的VPN隧道协议有(传输层,数据链路层)
    - PPTP(Point to Point Tunneling Protocol):点对点隧道协议
    - L2TP(Layer TWO Tunneling Protocol): 第二层隧道
    - IPsec(Internet Protocol Security):互联网安全协议
    - SSL VPN(如OpenVPN)

## tcpdump
+ linux版本tcpdump window版本WinDump
+ [https://www.tcpdump.org/manpages/tcpdump.1.html](https://www.tcpdump.org/manpages/tcpdump.1.html)
+ [https://danielmiessler.com/study/tcpdump/](https://danielmiessler.com/study/tcpdump/)

# 网络爬虫
+ 网络爬虫 (web Crawler),也叫做网络蜘蛛(Web Spider)
    - 模拟人类使用浏览器操作页面的行为,对页面进行相关的操作
    - 常用爬虫工具:Python的Scrapy框架

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732392724536-b355298d-e587-48ac-b8a4-ab263d1c07df.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732392948847-d415caf6-083a-4679-8c98-9f4a9f9b1c92.png)

## 网络爬虫 - 搜索引擎
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732393256065-7beb28e3-88f0-440b-85d4-5d7ce5049ec0.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732393262885-5cc81dc6-e191-429f-a0a6-c25373ac6303.png)

## 网络爬虫 - robots.txt
+ robots.txt是存放在网站根目录下的文本文件,比如:www.baidu.com/robots.txt
    - 用来告诉爬虫:哪些内容是不应被爬取的,那些是可以被爬取的
    - 有一些系统中的URL是大小写敏感的,所以robots.txt的文件名应该统一为小写
    - 他并不是一个规范，而是一种约定,所以并不能保证网站的隐私
+ 内容
    - 允许所有的爬虫
        * ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732393891467-7781c9d2-a7e1-4dbd-b30d-21c6597147fd.png)
    - 另一写法
        * ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732393897536-1937d528-044c-4403-8ee4-96af0a64acc0.png)
    - 仅允许特定的爬虫(name_spider是爬虫的名字)
        * ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732394027902-892f8c5f-39a8-4962-b141-6fb71b77a6f9.png)
    - 拦截所有爬虫
        * ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732394045716-10464c54-a64f-40bb-930b-65a77b4229ff.png)
    - 仅禁止爬虫访问特定目录:
        * ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732394083192-0a980891-085f-4681-bd8d-3365a2a54b2f.png)
    - 禁止所有爬虫访问特定目录
        * ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732394101805-3f781b7b-8b77-44fe-a961-c85a5bdf3e4b.png)
    - 禁止所有爬虫访问特定文件类型
        * ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732394144238-f99c74ef-1ab4-4194-bb49-b5bbbe9e2b40.png)

# 无线网络
+ 利用无线AP散播无线信号
+ 无线AP(Access Point):无线接入点

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732394183730-786722e4-023e-456a-8dd9-53c3ba2c66dd.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732394396387-8356fee7-9185-454d-9379-37b6eced9ddb.png)

# HTTP缓存
## 缓存(Cache)
+ Memory Cache 内存缓存
+ Disk Cache 硬盘缓存  

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732394632599-5ddfcdc6-77ea-4636-92b3-08bae08e4ca1.png)

+ 通常会缓存的情况是:GET请求+静态资源(比如 HTML,CSS,JS,图片等)

## 缓存 - 响应头
+ Pragma:最用类似与Cache-Control , HTTP1.0中的
+ Expires:缓存的过期时间(GMT格式时间),HTTP1.0中的
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732456620339-8440e94b-9924-404c-b791-837e552e89df.png)
+ Cache-Control:设置缓存策略
    - no-storage:不缓存数据到本地
    - public:允许用户,代理服务器缓存数据到本地
    - private:只润许用户缓存数据到本地
    - max-age:缓存的有效时间(多长时间不过其).单位秒
+ 优先级:Pragma -> Cache-Control ->Expires





## 缓存使用流程
![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1732456437329-e4f8a53e-2a64-47f9-8448-56dba22714d9.png)

