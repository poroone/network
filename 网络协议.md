<h1 id="HBjTz">C\C++跨平台原理</h1>
C\C++ 代码会根据不同平台进行编辑对应平台的格式 

windows(PE格式)     Mac(Mach-O格式)     Linux(ELF格式)

<font style="color:#DF2A3F;">! C\C++的跨平台:使用平台想换的编译器生成对应平台的可执行文件</font>

<font style="color:#DF2A3F;">C\C++编译后就可以直接生成平台对应的可执行文件</font>

<h1 id="SKfjJ">java的跨平台原理</h1>

1. *.java  =编译=>  *class(字节码文件 对操作系统来说是不可执行文件)
2. 在对应的平台安装JVM java虚拟机 
3. <font style="color:#DF2A3F;">JVM会加载*.class字节码进行解析字节码文件 后进行解析对应平台的机器码</font>
4. <font style="color:#DF2A3F;">一次编译到处运行</font>
5. 如果代码有语法错误,编译失败就不会生成字节码文件 
6. 从而就不会运行JVM程序 最后导致ajva程序运行失败

<font style="color:#DF2A3F;"> </font>

<h1 id="LdODE">网络协议</h1>

1. HTTP HTTPS SMTP MQTT REMP
2. 在特定的场景下用特定的协议，效果会更高 如处理文件FTP
3. 第三方库如: ios - AFN anroid - OKHTTP3

<h1 id="osLQG">网络协议模型</h1>
ISO国际标准化组织在1985年制定了网络互连模型

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1724833950209-623ff274-b2e4-42e4-865c-ece461e61c4b.png)

> OSI7层参考模型
>

---

7.应用层

6.表示层

5.会话层

4.传输层

3.网络层

2.数据链路层

1.物理层

> TCP/IP-协议
>

---

4.应用层

3.传输层

2.网络层

1.网络接口层



> 用于研究
>

---

5.应用层

4.传输层

3.网络层

2.数据链路层

1.物理层

<h1 id="rEqj3">网络基础概念</h1>
MAC地址 IP地址 路由器 交换机 集线器 同轴电缆



> 计算机之间的通信基础
>

1. 需要知道计算机的ip地址
2. 需要知道计算机的Mac地址(网卡地址),输送数据包到网卡,被网卡接收
3. 如果网卡发现数据的目标mac不是自己,就会将数据丢弃,不会传递给上一层进行处理
4. 数据包中会有
    1. 源ip地址 ->目标ip地址
    2. 源mac地址 ->目标mac地址
    3. 等

<h1 id="mkSl8">网络设备之间的通信</h1>
> 有线连接 - 交叉线网线  直连
>

1. 如何拿到MAC地址 

在第一次发送ICMP协议的时候需要知道对方的ip和MAC地址

从而进行ARP协议(广播协议)只要和他相连接通的设备都会收到这个广播(广播只能同一个网段传播的)

ARP协议为了拿到对方的mack地址(并且具有缓存效果)

    1. ARP完整的一次协议 会进行三步
        1. 进行组包
        2. 进行发送
        3. 进行返MAC

当发送广播的时候目标mack地址是FFFF.FFFF.FFFF (F十六进制在二进制中是1)代表全发送全网段也就是广播全接收

> 有线连接 
>

1. **网线(交叉线)直接连接两台电脑**
2. ****
    1. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725293965432-a8acdec2-5c6b-49ac-a886-ea014dbb96dd.png)
3. **同轴电缆(半双工通信 容易冲突(冲突域) 不安全全都发 中间断了整个瘫痪 技术老)**
    1. 半双工通信同一时间只允许一个方向的发动
    2. 如果目标有一个多个接收会冲突进行等待下次随机时间发送
    3. 同轴电缆在发送后,会往每个地方都会发送可能会被抓包
    4. 如果中间断开那么信号可能会回来发送给自己从而瘫痪,影响整条线上的设备
    5. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725285782659-024f38aa-7e7c-4b36-9e6f-cf15e1699f5b.png)
4. **集线器(Hub)(半双工通信 容易冲突 不安全 和同轴电缆一样没智 商)**
    1. 同一时间也只允许同一方向的发送
    2. 目标有多个接受会冲突,等待一会会重新发送
    3. 可能会被抓包
    4. 但是其中一个发生问题不会影响到其他的设备
    5. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725286068656-3617c005-2093-4ee1-a230-9587ee5cd69e.png)
5. **网桥(有学习性 隔绝冲突域 )**
    1. 网桥会维护一个表( ip MAC)
    2. 会进行判断发送请求的方向如果是发送方当前域就不会发给别的域
    3. 从而实现隔断,并且可以使域之间内部同时通信不会有冲突 
    4. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725288182392-a3cc4683-da1c-427d-badb-b08eacbe0bd6.png)
6. **交换机 (Switch 局域网的最终方案 | 相当于更多接口的网桥 全双工通信 安全)**
    1. 可以同时进行来回通信
    2. 具有学习能力可以记录 ip mac在记录后不会广播发送 会指定目标发送
    3. 因为会记录所以更加安全,发的包不会发送到别的设备上从而防止被抓包的风险
    4. 如果全球的设备都用交换机连接会形成广播风暴
    5. 
    6. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725293535474-bf527450-f04d-4e05-a6b9-5c2a7835204a.png)
7. **网线直连,同轴电缆,集线器,网桥,交换机**
    1. 连接设备都需要在同一网段 	<font style="color:#74B602;">192.168.1.</font>20 | <font style="color:#74B602;">192.168.1.</font>10   
    2. 连接设备都必须处在同一广播域
8. **路由器(router 隔绝广播域)**
    1. 主机在发送数据之前,首先会判断目标主机的IP地址跟它是否在同一个网段
        1. 在同一个网段:ARP协议 通过交换机\集线器传递数据
        2. 在不同网段:通过路由器转发数据
    2. 网关层(Gateway)
    3.    ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725293851042-3fa6cdf0-206f-448e-9963-14d3cccd7094.png)

<h1 id="mO7Gf">MAC地址</h1>
每个网卡都有一个6字节(48bit)的MAC地址(Media Access Control Address)

全球唯一,固化在网卡的ROM中,由IEEE802标准规定

1. 前三个字节OUI ,组织唯一标识符
2. 由IEEE的注册管理机构分配给厂商
3. oui查询
    1. [standards-oui.ieee.org/oui/oui.txt](https://standards-oui.ieee.org/oui/oui.txt)
    2. [MAC地址查询 - 根据网卡MAC地址查询厂商信息 - MAC地址查厂商 (bmcx.com)](https://mac.bmcx.com/)

| 资质唯一标识符  |  网络接口标识符 |
| --- | --- |
| 40-80-20 | 0E-6A-7D |


<h2 id="uNY5a">Mac地址的表示格式</h2>
> ipconfig /all 可以查看物理地址(网卡地址) 
>

1. windows中 使用 - 进行连接
    1. xx-xx-xx-xx-xx-xx-xx
2. Linux Android Mac iOS 使用:连接
    1. xx:xx:xx:xx:xx:xx
3. packet Tracer
    1. XXXX:XXXX:XXXX
4. 当48位全为1时,代表广播地址
    1. FF-FF-FF-FF-FF-FFF

>  ARP状态
>

dynamic 动态 学习通过ARP协议获取mac 默认缓存两分钟

static 静态 缓存时间较长

 arp -a [主机地址] :查询ARP缓存

arp -d[主机地址] :删除ARP缓存

arp -s 主机地址 MAC地址 :添加一条缓存信息(这是静态缓存,存储时间较久,不同系统的存储时间不同)

<h1 id="w5PLi">IP地址</h1>
<h1 id="spojF">IP地址  </h1>
最初版本是IPV4 ,32bit(4字节),2019年11月25日,全球的IP地址已经用完

后推出ipv6版本 128bit(16字节)

| 1100 0000 | 1010 1000 | 0000 0010 |  0000 0110 |
| --- | --- | --- | --- |
| 第一部分 | 第二部分 | 第三部分 | 第四部分 |
| 192 | 168 | 2 | 6 |


1. ip地址由于两个部分组成:网络标识(网络ID),主机标识(主机ID)
    1. 同一网段的计算机,网络ID相同
    2. 通过子网掩码(subnet mask) 可以计算出网络ID :子网掩码& IP地址

---

IP地址:192.168.2.6

子网掩码:255.255.255.0

网段:192.168.2.0

当前网段可用的主机数是 256-2 应为0(主机位全0代表一个网段) 和255(广播)不可用

---



当子网掩码是1的时候原本ip是什么就是什么

1. 子网掩码是0的时候都是0
    1. 1100 0000 . 1010 1000 . 0000 0010 . 0000 0110
    2. 1111 1111 . 1111 1111 . 1111 1111 . 0000 0000
1. 计算后的 网段192.168.2.0
    1. 网络id 192.168.2
    2. 主机id .0 

<h2 id="vCXlh">IP地址的分类</h2>


1. A类
    1. 网络id必须0开头(8bit) 主机ID (24bit)
    2. 默认子网掩码是255.0.0.0
    3.   ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725351851596-8b3096c6-f08b-48b4-b130-f011b9911e8e.png)
2. B类
    1. 网络id必须10开头(16bit) 主机ID (16bit)
    2. 默认子网掩码是255.255.0.0
    3. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725352128339-f0ba486e-6171-4a68-b52c-06399a019f84.png)
3. C类
    1. 网络id必须110开头(24bit) 主机ID (8bit)
    2. 默认子网掩码是255.255.255.0
    3. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725352329448-df7ef60e-9318-4b22-94b4-570175d3edc8.png)
4. D类
    1. 以1110开头,多播地址
    2. 无子网掩码
    3. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725352398473-6d54f12e-0d09-44bd-97c1-54f4b4ee3cc1.png)
5. E类
    1. 以1111开头 保留位今后使用
    2. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725352402334-dd566b83-fbdc-41f0-a53a-0c6b5de7dc74.png)
6. <font style="background-color:#74B602;">只有A\B\C类地址才能分配给主机</font>
7. 主机ID为全0,代表主机所在的网段
8. 主机ID全为1,代表主机所在的网段的全部主机(广播) 

<h1 id="kGUur">子网掩码的CIDR表示方法</h1>
CIDR (classless inter-Domain Routing): 无类别域间路由

1. 子网掩码的CIDR表示方法
    1. 123.210.100.200/24 代表子网掩码由24个1 ,也就是255.255.255.0	
    2. 123.210.100.200/16 代表子网掩码由16个1 ,也就是255.255.0.0	

<h2 id="J1M1z">子网划分 </h2>
> 等长子网划分
>

A子网 :192.168.0.0/25 ,子网掩码:255.255.255.128

192.168.0.1~192.168.0.126 ,126台

B子网 :192.168.0.128/25 ,子网掩码:255.255.255.128

192.168.0.129~192.168.0.254,126台

> 变长子网划分
>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725503733979-17c8c3c3-5204-493f-8da1-24fd46a781a0.png)

1. 设上图是对192.168.0.0/24 进行变长子网划分
    1. C网段  子网掩码是  255.255.255.128 /25  192-223
    2. B网段  子网掩码是  255.255.255.192 /26  128-191
    3. A网段  子网掩码是  255.255.255.224 / 27 0-127
    4. E网段   子网掩码是 255.255.255.252 /30   224-239
    1. D网段  子网掩码是 255.255.255.252 /30   240-255

<h3 id="rfOZl">测试</h3>
---

A计算机192.168.0.10/24  <==> B计算机192.168.10.10/16 访问

1. 192.168.0.10/24 访问 192.168.10.10的时候会拿自己的子网掩码进行换算
    1. 192.168.0.10/24 => 192.168.0.0
    2. 192.168.10.10/24=>192.168.10.0
    3. 得出真正的ip后发现192.168.0.0 和192.168.10.0不在同一个网段因此无法访问
2. 192.168.10.10/16 访问192.168.0.10/24  的时候同理也会拿自己的子网掩码进行换算
    1. 192.168.10.10/16 => 192.168.0.0
    2. 192.168.0.10/16 => 192.168.0.0
    3. 得出真正的ip后发现192.168.0.0 和192.168.0.0在同一个网段因此B计算机可以访问A计算机
3. 当一个计算机要访问另外一个计算机时会拿自己的子网掩码去进行换算不会拿对方的子网掩码如果在同一个网段就可以进行访问

<h2 id="s67OO">超网</h2>
和子网反过来,他是将多个连续的网段合并成一个更大的网段

如一个有200台计算机使用192.168.0.0/24网段 ,现在希添加200台设备到同一网段

如果有200台设备在192.168.1.0/24网段 ,另外200台在192.168.0.0/24网段

可以进行合并 192.168.1.0/24 192.168.1.0/24为一个网段 192.168.0.0/23(子网掩码往左移动一位)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725507970550-1dd3e350-0076-446d-80de-d380b7ebaf65.png)



<h2 id="JatQd">合并网段的规律</h2>


1. 假设n是2的k次幂(k>=1)
2. 子网掩码左移K位能够将能够合并n个网段
3. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725510522618-d24d0b32-6349-497c-a859-9186ebe06bdb.png)
4. 假如一个网段的网络号以二进制0结尾,那么由他开始连续的2个网段,能通过左移1位子网掩码进行合并
5. 假如一个网段的网络号以二进制00结尾,那么由他开始连续的4个网段,能通过左移2位子网掩码进行合并
6. 假如一个网段的网络号以二进制000结尾,那么由他开始连续的8个网段,能通过左移3位子网掩码进行合并

<h2 id="IEXqc">判断一个网段是子网还是超网</h2>

1. 如果当前网络的子网掩码位数比子网掩码多就是子网
2. 如果当前网络的子网掩码位数比子网掩码少就是超网
3. 查看网段是A类网还是B类网还是C类网
    1. A类网的子网掩码是8
    2. B类网的子网掩码是16
    3. C类网的子网掩码是24
    4. -------------------------------------------------------------------------
    5. 25.100.0.0/16是一个A类子网
    6. 200.100.0.0/16是一个C类超网

<h1 id="ZP3MU">路由</h1>

1. 路由器默认情况下只知道和他直连的设备,非直连的网段需要通过静态路由,动态路由告诉他
2. 静态路由
    1. 管理员手动添加路由信息
    2. 适用于小规模网络
3. 动态路由
    1. 路由通过路由算则协议(如 RIP , OSPF)自动获取路由信息
    2. 适用于大规模网络

> 特定主机路由
>

指定了要访问的ip地址 写死

| 网络 | 子网掩码 | 下一跳 |
| --- | --- | --- |
| 192.168.1.10 | 255.255.255.255 | 194.163.1.1 |
| 192.168.2.10 | 255.255.255.255 | 194.163.1.1 |


> 网络路由
>

网段

| 网络 | 子网掩码 | 下一跳 |
| --- | --- | --- |
| 192.168.1.0 | 255.255.255.0 | 194.163.1.1 |
| 192.168.2.0 | 255.255.255.0 | 194.163.1.1 |


> 汇总路由
>

范围写大

| 网络 | 子网掩码 | 下一跳 |
| --- | --- | --- |
| 192.168.0.0 | 255.255.0.0 | 194.163.1.1 |
| 192.168.0.0 | 255.255.0.0 | 194.163.1.1 |


> 默认路由
>

默认直接访问下一个路由

| 网络 | 子网掩码 | 下一跳 |
| --- | --- | --- |
| 0.0.0.0 | 0.0.0.0 | 194.163.1.1 |


<h1 id="YoHIf">数据包的传输过程</h1>
数据包的传输

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725542936478-286ed426-e099-47c1-8a19-af7d10bcabd4.png)

1. 数据包在最开始传输的时候会进行封装一个数据包大致为下图如果不是当前网段的就会找当前的路由器进行转发
    1. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725525943861-e77a013c-6a35-423d-bfe3-369b4a948ca2.png)
2. 当前路由器发现目标IP不在我这里更改当前MAC地址为当前路由口的MAC和目标路由口的MAC然后发给下一个路由器1
    1. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725543083100-4b48ef0a-027c-40ce-9a8a-d81fa6e13701.png)
3. 直到找到对应的ip
    1. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725543190382-200df401-5533-45ce-b655-0f42d91fd587.png)

<h1 id="HFXlC">网络 互联网  因特网</h1>

1. 网络 就是多台设备连在一起就是一个小型网络
    1. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725543972822-da891ce9-1aa3-46c8-a340-4a72c7cdc36c.png)
2. 互联网 利用路由器吧多个网段连接起来形成小型的互联网
    1. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1725544228647-fc55ba98-2c1f-4372-9a4c-cc95de928717.png)
3. 因特网 全国最大的互联网 就是因特网(Internet)
    1. 将全世界所有的计算机连接在一起
    2. 一般使用大写I开头的Internet特指因特网

<h2 id="OJSD1">ISP   ( internet 服务提供商)</h2>
 如 移动 电信 网通 铁通等 

<h2 id="SF701">网络分类</h2>

1. <font style="background-color:#ECAA04;">局域网</font> 
( Local Area Network) LAN
    1. 一般是范围几百米到十几公里内的计算机所构成的计算机网络
    2. 常用于公司 家庭 学校 医院 机关 一栋大楼等
    3. 局域网中使用最广泛的网络技术叫: 以太网(Ethernet)
2. W<font style="background-color:#ECAA04;"></font>LAN (wireless LAN) 无线局域网
3. <font style="background-color:#ECAA04;">城域网</font> (Metroplitan Area Network) MAN
    1. 一般范围是数十公里到数百公里,可以覆盖一个城市
4. <font style="background-color:#ECAA04;">广域网</font>  (Wide Area Netword) WAN
    1. 一般范围是几百公里到几千公里,可以覆盖一个国家,通常都需要租用ISP的线路

<h2 id="Ht4MR">常见的几种接口</h2>
1. FastEthernet 
    1. 快速以太网接口(100M)
2. GigabitEthernet 
    1. 千兆以太网接口
3. Serial (路由器和路由器之间连接)
    1. 串行接口

<h2 id="sdDBQ">公网IP丶私网IP</h2>

1. 公网ip(public)
    1. internet上的路由器只有到达公网的路由表,没有到达私网的路由表
2. 私网ip(Private)
    1. 主要用于局域网,下面是保留的私网网段
        1. A类: 10.0.0.0/8,1个A类网络
        2. B类: 172.16.0.0/16 ~ 172.31.0.0/16, 16个B类网络
        3. C类: 192.168.0.0/24 ~ 192.168.255.0/24,256个C类网络

<h2 id="pXIkW">NAT </h2>

1. 私网IP访问Internet需要进行NAT转换位公网IP
    1. NAT(Network Address Translation)
2. NAT的特点
    1. 可以节约公网IP资源
    2. 会隐藏内部真实IP
3. NAT的分类
    1. 静态转换
        1. 手动配置NAT映射表
        2. 一对一转换
    2. 动态转换
        1. 定义外部地址池,动态随机转换
        2. 一对一转换
    3. PAT(port Address Translation)
        1. 多对一转换,最大程度节约公网IP资源
        2. 采用端口多路复用方式,通过端口号标识不同的数据流
        3. 目前应用最广泛的NAT实现方式

<h1 id="nDWlL">网络分层</h1>
<h2 id="mItf4">网络互连模型</h2>
ISO 组织在1985年制定了网络互连模型

**OSI参考模型,具有7层结构(参考)**

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726798092299-2dc4f6a5-54cb-4d3f-8853-c36de6cf22ab.png)

**TCP/IP 协议模型,具有4层结构(实际应用)**

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726798137138-fee0ddd9-14b1-4fda-bd5e-538a9813aef8.png)

**网络5层模型(学习研究)**

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726798260061-ed5f33d1-27f7-4a21-96d5-0f11a3bf7c75.png)

<h3 id="VVYXJ">请求过程</h3>
1. 客户端进行对包逐一封装
2. 服务端进行对应的解包
    1. 应用层会携带上报文和用户数据 
    2. 运输层会加上段  确保包的可靠传输 重传机制 包的完整机制
    3. 网络层会加上包 附带源ip和目标ip地址
    4. 数据链路层会加上帧 附带mac地址和目标mac地址
    5. 物理层传输的是比特流

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726798421026-6536ad62-20f5-46a8-9dcb-81d4291caf71.png)

1. 应用层会加上报文和 用户的携带数据
2. 传输层会进行加料加料后会叫做段
3. 网络层会进行封装封装后叫包
4. 数据链路层进行封装后为帧
5. 最后经过物理层后就变成比特流进行传输

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726801322764-22d4df3e-5f48-47ef-89df-d4cc9bac1649.png)

<h1 id="K97aw">物理层(Physical)</h1>
> 物理层定义了接口标准 , 线缆标准 , 传输速率,传输方式等
>

<h2 id="NtlUj">数字信号 模拟信号</h2>
<h3 id="Jgw5i">模拟信号(Analog Signal)</h3>
1. 连续的信号,适合长距离传输
2. 抗干扰能力差,受到干扰时波形变形很难矫正 

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726802294012-c3f8a00f-8b5e-4e04-baac-879f69e7c23f.png)

<h3 id="stCJb">数字信号(Digital Signal)</h3>
1. 离散的信号,不适合长距离传输
2. 抗干扰能力强,收到干扰时波形失真可以修复

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726802607525-9030c22f-f018-4bba-8f62-8f9afa14ea93.png)

<h2 id="McCFO">数据通信模型</h2>
**局域网通信模型**

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726803156368-b268912d-3e8d-4ca1-89fe-14f21ac3b51f.png)
+ 网线不能超过100米 可通过不停接交换机进行加长

**广域网通信模型**

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726803903763-d1ad0161-9524-4d28-8245-d91a2233cb45.png)

<h2 id="RbwrQ"> 信道(Channel)</h2>
<details class="lake-collapse"><summary id="ueaa16ae5"><span class="ne-text">信道</span></summary><p id="ub48c9a7f" class="ne-p"><span class="ne-text"> 信道传输的通道,一条传输介质上(比如网线) 上可以有多条信道</span></p></details>
<details class="lake-collapse"><summary id="u2a5fcb49"><span class="ne-text">单工通信</span></summary><ol class="ne-ol"><li id="u5c00f21b" data-lake-index-type="0"><span class="ne-text">信号只能往一个方向传输,任何时候都不能改变信号的传输方向</span></li><li id="u35ba8a1d" data-lake-index-type="0"><span class="ne-text">无线电广播,有线电视广播 </span></li></ol></details>
<details class="lake-collapse"><summary id="u85f73817"><span class="ne-text">半双工通信</span></summary><ol class="ne-ol"><li id="uc10977a3" data-lake-index-type="0"><span class="ne-text">信号可以双向传输,但必须是交替进行,同一时间只能往一个方向传输</span></li><li id="uf0e02df8" data-lake-index-type="0"><span class="ne-text">对讲机  </span></li></ol></details>
<details class="lake-collapse"><summary id="u28645b18"><span class="ne-text">全双工通信</span></summary><p id="ud1e433c3" class="ne-p"><span class="ne-text">信号可以同时双向传输</span></p><p id="u8a64eaaf" class="ne-p"><span class="ne-text">手机</span></p></details>
<h1 id="FjnFf">数据链路层(Data Link)</h1>
> 链路 : 从一个节点到相邻节点的一段物理线路(有限或 无线) , 中间没有其他交换节点
>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726812677491-0ca733af-5ee3-433e-a77a-d5bd792f6417.png)

1. 数据链路 :  在一条链路上传输数据时,需要有对应的通信协议来控制数据的传输
2. 不同的数据链路,所用的通信协议可能是不同的
3. 广播信道 : CSMA/CD协议 (如同轴电缆,集线器等组成的网络)
4.  点对点信道 : PPP协议(比如两个路由器之间的通信)



1. 数据链路层的三个基本问题
    1. 封装成帧
    2. 透明传输
    3. 差错检验

<h2 id="Rlyo6">1.封装成帧</h2>
会对网络层的数据进行封装 帧数据在中 会在其前面添加帧开始符和尾部添加帧结束符从而进行区分一段数据

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726816861217-bb25f8c6-4bad-4c3d-88b9-18059a09c539.png)

1. 帧 (Frame) 的数据部分
    1. 就是网络层传递下来的数据包（IP数据包,Packet）



1. 最大传输单位MTL(Maximum Transfer Unit)
    1. 每一种数据链路层协议都规定了所能够传送的帧的数据长度上线
    2. 以太网的MTU为1500个字节

<h2 id="ZWu4x">2.透明传输</h2>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726817219450-f40d9c04-434a-4e29-95bc-51481205cff6.png)

1. 使用SOH  (Start Of Header) 帧开始
2. 使用EOT (End Of Transmission) 作为帧结束符

**数据中一旦出现SOH EOT 就需要进行转义 **

为了防止数据中出现SOH 或EOT从而造成数据被丢弃会对数据进行检测

如果有OSH EOT ESC 会在其前面进行添加一个ESC进行转义

在接收方拿到后会进行去除ESC从而拿到完整的数据

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726817333407-b5bada27-4078-44e6-8061-727755634673.png)

<h2 id="Ig0Bv">3.差错检验</h2>
在发送端会将 数据链路层首部和帧的数据部分进行计算 生成FCS 后拼装进行发送

接收端在接收到后也会对 数据链路层首部和帧的数据部分进行计算 用生成的FCS和 发送来的Fcs进行对比如果一样代表数据没有丢失或者改变 否则代表数据有问题 网卡会进行丢包

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1726817572472-3a9d329e-df3a-48b3-9885-630dcb6e79f5.png)

<h2 id="JBA0a">CSMA/CD协议</h2>
CSMA/CD协议  (载波侦听多路访问/冲突检测)

---

1. 使用了CSMA/CD的网络可以被称为以太网(Ethernet) ,他传输的是以太网帧
2. 以太网帧的格式是 : Ethernet V2标准,IEEE的802.3标准
3. 使用最多的是Enternet V2标准

---

1. 为了能够检测正在发送的帧是否产生了冲突,以太网的帧至少是64字节

---

1. 用交换机组件的网络,已经支持全双 工通信,不需要再使用CSMA/CD ,但他传输的帧仍然是以太网帧
2. 所以,用交换机组建的网络,依然可以叫做以太网

---

<h2 id="M4JZi">Ethernet V2帧的格式</h2>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1727187587431-5c2f6bd6-d9c4-44c2-a984-1c6589117c92.png)

MAC层

会生成FCS , FCS 根据数据传输的内容 加 MAC地址和源MAC地址 加 类型(首部) 加 数据生成一个FCS用来代表当前数据

接收方也会生成一个FCS 从而进行对比如果相同代表没有更改过,如果不同代表数据不一致,会进行丢包

数据最多是46-1500 

<h2 id="t2t8N">Ethernet V2标准 </h2>
当数据部分的长度小于46字节时

数据链路层会在数据的后面假如一些字节填充

接收端会将添加的字节去掉 

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1727596649082-288254ad-4b3f-49a6-b640-5ddf27474505.png)

+ 长度总结
    - 以太网帧的数据长度:46-1500字节(蓝色部分)
    - 以太网帧的长度:64-1518字节(源MAC+ 目标MAC+网络类型+数据+FCS)(全部)

<h2 id="iCMTF">PPP协议(Point to Point Protocol)</h2>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728523348615-27bd0e44-f46e-40d9-b4f1-dfaf178b0997.png)

+ Address字段:图中的值是0xFF,形同虚设,点到点通信不需要源MAC,目标MAC地址
+ Control字段:图中的值是0x03,目前没什么作用
+ Protocol字段:内部用到的协议类型
+ 帧开始符,帧结束符:0x7E

<h2 id="OgXUj">PPP协议-字节填充</h2>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728539510850-05b88f03-6d3b-4474-8e66-25236356d78d.png)

+ 将0x7E替换成0x7D5E
+ 将0x7D替换成0x7D5D

<h2 id="URzt4">网卡 (在链路层和物理层)</h2>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728539618545-c29ee37d-d44d-4c3d-8e75-5b5c9c58cb36.png)

+ 网卡在收到一个帧,首先会进行差错校验,如果校验通过则接受,否则丢弃
+ wireshark抓到的帧没有FCS,应为他抓到的是差错校验通过的帧(帧尾的FCS会被硬件去掉)

<h1 id="jVMyy">网络层(Network)</h1>

+ 网络层数据包(IP数据包,Packet)由首部,数据2部分组成
+ 数据:一般由传输层传递下来的数据段(Segment)
+   ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728542077522-2d10eb7c-d0cd-4b3b-9955-bd187f3c5695.png)

<h2 id="bAO98">网络层首部 - 版本,首部长度,区分服务,总长度</h2>

+ 版本(version)
    - 占4位
    - 0b0100:IPV4
    - 0b0110:IPV6

<h4 id="jjBcY">首部长度(Header Length)</h4>
+ 占4位 ,二进制乘以4才是最终长度
+ 0b0101 : 20(最小值5)
+ 0b1111 : 60(最大值15) 	

<h4 id="CR9l0">网络层首部 - 总长度</h4>

+ 总长度
    - 占16位
    - 首部 + 数据的长度之和,最大值是65535 
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728634669752-b10f255f-9e06-439c-914d-89f2db5d6c4a.png)
    - 由于帧的数据不能超过1500字节,所以过大的ip数据包,需要分成片(fragments) 传输给数据链路层
    - 每一片都有自己的网络层首部(ip首部)


<h4 id="ToJKO">网络层首部 - 标识,标志 ,片偏移</h4>

+ 标识(ldentification)
    - 占16位
    - 数据包的ID，当数据包过大进行分片时,同一个数据包的所有片的标识都是一样的
    - 有一个计数器专门管理数据包的ID,每发一个数据包,ID就加1
+ 标志(Flags)
    - 占3位
    - 第1位(Reserved Bit) : 保留
    - 第2位(Dont Fragment) : 1代表不允许分片,0发表允许分片
    - 第3位(More Fragments) : 1代表不是最后一片,0代表是最后一片
+ 片偏移(Fragment Offset)
    - 占13为
    - 片偏移乘以8:字节偏移
    - 为保证片偏移能够存储下所以存储的时候使用进行片偏移除以8
    - 每一片的长度一定是8的整数倍数
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728958073471-cb271d02-bb88-4786-9fd6-94c8ddec7431.png)

网络层首部 - 协议,首部校验和,生存时间

+ 协议(Protocol)
+ 占8位
+ 表明所封装的数据是使用了什么协议

| 协议 | ICPM | IGMP | IP | TCP | EGP | IGP | UDP | IPV6 | ESP | OSPE |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 值(十进制) | 1 | 2 | 4 | 6 | 8 | 9 | 17 | 41 | 50 | 89 |


+ 首部校验和(Header Checksum)
    - 用于检查首部是都有错误
+ 生存时间(Time To Live, TTL)
    - 占8位
    - 每个路由器在转发之前将会TTL减1,一旦发现TTL为0，路由器会返回错误报告
    - 观察使用ping命令后的TTL,能够推测出对方的操作系统,中间经过了多少个路由器
    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728964743068-1ce17b90-7eb6-470c-9c30-233841f50469.png)

<h1 id="VGwoJ">传输层(Transport)</h1>

+ 传输层有2个协议
+ TCP( Transmission Control Protocol) ,传输控制协议
+ UDP(User Datagram Protocol) ,用户数据报协议
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728969786989-527926a0-8b15-4213-a96e-f341e816e980.png)

<h2 id="nxX44">UDP - 数据格式</h2>

+ UDP是无连接的,减少了建立和释放连接的开销
+ UDP尽最大能力交付,不保证可靠交付
+ 因此不需要维护一些复杂的参数,首部只有8个字节(TCP的首部至少20个字节)
+ UDP数据部分
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728975031256-76a99cac-ed1a-4426-9c5b-5892693e23c3.png)
+ UDP长度
+ 占16位,首部的长度+数据的长度  

<h3 id="HisqT">UDP - 检验和 (Checksum)</h3>

+ 检验和的计算内容: 伪首部 + 首部 + 数据
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728975229901-db6390c2-be06-43ff-9bbc-3ffa80d1933a.png)

<h3 id="POuqw">端口(Port)</h3>
+ UDP首部中端口是占用2字节
+ 可以推测出端口号的取值范围是:0-65535
+ 客户端的源端口是临时开启的随机端口
+ 防火墙可以设置开启\关闭某些端口来提高安全性

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1728978695668-871bc8fb-5beb-4005-b0ec-c39a12d01ebc.png)

+ 常用命令
+ netstat -an : 查看被占用的端口
+ netstat -anb :查看被占用的端口,占用端口的应用程序
+ telnet 主机 端口 :查看是否可以访问主机的某个端口

<h2 id="rHF2l">TCP</h2>
<h3 id="ToyfX">TCP数据格式</h3>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729434712387-a621860f-a601-431b-8f0a-a88478fec255.png)

<h3 id="zAVyy">数据偏移</h3>
+ 占4位: 取值范围是 0x0101~0x1111
+ 乘以4:首部长度(Hander Length)
+ 首部长度是20~60字节



+ 保留
+ 占6位置,目前为0

<h3 id="tpW3Y">TCP与UDP头部区别</h3>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729435430919-5ac92194-4d24-4db6-82c8-dcfea3c3d40a.png)

UDP的首部中有16位的字段记录了整个udp报文段的长度(首部+数据)

但是TCP的首部中仅仅有4位的字段记录了TCP报文段的首部长度,并没有字段记录TCP报文段的数据长度



+ UDP首部中占16位的长度字段是冗余的,纯粹是为了保证首部是32bit对齐
+ TCP\UDP的数据长度,完全可以有IP数据包的首部推测出来
    - 传输层的数据长度=网络层的总长度-网络层的首部长度-传输层的首部长度

<h3 id="FEfQq">TCP - 检验和(Checksum)</h3>
跟UDP一样TCP检验和计算内容:伪首部 + 首部 + 数据

伪首部:占用12字节,仅在计算校验和时起作用,不会传递给网络层

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729436506211-62ac5cff-6da0-4d63-ace6-b2153400d6a0.png)

<h3 id="PvYXK">TCP - 标志位(Flags)</h3>
+ URG(Urgent)

当URG= 1,紧急指针字段才有效,表明当前保温段中有紧急数据,应优先尽快传送



+ ACK (Acknowledgment)

当ACK=1时,确认号字段才有效



+ PSH(Push)



+ RST(Reset)

当RST=1时,表明连接中出现严重差错,必须释放连接,然后再重新建立连接  



+ SYN(Synchronization)

当SYN=1,ACK=0时,表明这是一个建立连接的请求

若对方同意建立连接,则回复SYN=1,ACK=1



+  FIN(Finish)

当FIN=1,代表数据发送完毕,要求释放连接

<h3 id="HD3eY">TCP -  序号 - 确认号 - 窗口</h3>
<h4 id="uhYfW">原生 序号 确认号</h4>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729965820441-fd0e9685-51ad-4272-8046-acc3d6b70eff.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729950442628-6dae7875-fcd4-45ce-8623-31bb541080b5.png) 

<h4 id="Qf9Fb">相对 序号 确认号</h4>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729952190326-0f0d35f4-ff35-4342-af47-967a426d92d5.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729952724387-86d567dc-f1f4-4d1e-b46c-cc63d51dfb24.png) 

+ 序号(Sequence Number)
    - 占4字节
    - 首先,传输过程的每一个字节都会有一个编号
    - 在建立连接后,序号代表:这一次传给对方的TCP数据部分的第一字节的编号

 

+ 确认号(Acknowledgment Number)
    - 占4字节
    - 在建立连接后,确认好代表,期望对方下一次传过来的TCP数据部分的第一个字节的编号



+ 窗口(window)
    - 占2字节
    - 整个字段有流量控制功能,用以告知对方下一次允许发送的数据大小(字节为单位

<h4 id="AOPwG">相对 + 原生 序号 确认号</h4>

1. 发送方发送建立连接请求携带 SYN=1首次建立连接 seq=0 ack=0

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729957861347-b950f2c1-6ba5-4ce5-a234-a0bb60c37ef8.png)

2. 接收方响应发送方的请求 携带SYN=1 首次建立简介seq=0 ack=1

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729956730091-beab7e3e-49a4-444d-859b-4aa212936562.png)

3. 发送方收到后知道接收方需要1开头的数据准备发送 SYN=0 已经不是首次建立连接了 seq=1 ack=1

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729957807052-4be59e3c-40d8-4a43-a568-1619bd8d0c87.png)

4. 上方TCP三次握手完毕开始HTTP传输数据 响应上一次接收方的信息 所以seq=1 ack=1

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729964373635-4c5e4b5f-cad0-4d47-8e43-df73a56fce64.png)

5. 开始发送数据 对上一次的数据 所以是 seq=s2+1 ack=s1+k(数据字节)+1 

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729965001826-48f84dda-6966-44dd-9b37-6665d21d4929.png)  
6. 对上一次的数据 seq =s2+b1(上一次发送的部分)+1 ack=s1+k+1

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729965189067-fea83da6-ddba-420c-ae78-700be24a0b6a.png)

7. 对上一次的数据 seq =s2+b1(上上一次发送的数据部分)+b2(上次发送的数据部分)+1 ack=s1+k+1

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729965368025-ef2915f9-754e-443d-b86e-48d8e874905d.png)

8. 对上一次的数据 seq =s2+b1(上上一次发送的数据部分)+b2(上次发送的数据部分)+b3+1 ack=s1+k+1

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729965376654-00f8ac57-ef27-46fb-b39d-7622e43d7f41.png)

9. 收到了对方发送的数据后 返回seq=k+1 ack=b1+b2+b3+b4+1

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729965857251-e6266fd4-f667-41d2-96d0-925afbac1c09.png)

**  第N个包的序号:是前面N-1个包的总长度+1 **

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730023300014-919f39b9-0adc-46d8-b290-6494301d6150.png)

<h3 id="CR0zJ">可靠控制</h3>
<h4 id="RROMk">停止等待ARQ协议</h4>
+ ARQ(Automatic Requeat-reQuest) 自动重传请求

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729439421418-aebbe53c-ea4b-4cac-88de-05953134253b.png)

+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729489237380-5c4e20bb-4134-44cf-a5f4-af157843112e.png)



<h4 id="YzCQO">连续ARQ协议+ 滑动窗口协议</h4>
 

+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729489548404-b22ece16-9d13-4b6d-bb5f-e60f4979da0c.png)
+ 如果接收窗口最多能接受4个包
    - 但对方只发送了两个包
+ 接收方如何确定后面还有没有2个包
    - 接收方会等待一定时间后如果没有第三个包
    - 就会返回确认收到2个包给发送方
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729490046884-cdfe259e-4bff-4328-a9ba-62f377ce308d.png)

<h4 id="HFG7Z">SACK(选择性确认)</h4>

+ 在TCP通信过程中,如果发送序列中间某个数据包丢失(比如1 , 2 , <font style="color:#DF2A3F;">3 </font>, 4 , 5 中的<font style="color:#DF2A3F;">3</font>丢失了)
+ TCP会通过重传最后确认的分许后续的分许(最后确认的是2,会重传<font style="color:#DF2A3F;">3</font> 4 5)
+ 这样原先已经正确传输的分组也可能重复发送(比如4 5 ),降低了 TCP 性能
+ 为改善上述情况,发展出SACK(Selective Acknowledgment.,选择性确认 ) 技术
+ 告诉发送方哪些数据丢失,哪些数据已经提前收到
+ 使TCP只重新发送丢失的包(比如 <font style="color:#DF2A3F;">3</font> ),不用发送后续所有的分组(比如4 , 5 )
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729495756193-27626522-6d0a-4d27-a78b-74213583aa40.png)
+ SACK信息会放在TCP首部的选项部分
+ Kind:占1字节,值为5代表这是SACK选项
+ Length:占1字节,表明SACK选项一共占用多少字节
+ left Edge:占4字节左边界
+ Right Edge:占4字节,右边界
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729495911843-04f805e5-ec43-4a82-b35a-8eac00c53477.png)
+ 一对边界信息需要占用8字节,由于TCP首部的选项部分最多40字节,所以
+ SACK选项最大携带4组边界信息
+ SACK选项的最大占用字节数=4*8+2=34

<h3 id="bPWqe"> 流量控制</h3>
> 让发送方的发送速率不要太快,让接收方来得及接收处理
>
> 通过确认报文中的窗口字段开控制发送方的发送速率
>
> 发送方的发送窗口大小不能超过接收方给出窗口大小
>

+ 如果接收方的缓存区满了,发送方还在疯狂的发送数据
+ 接收方只能把收到的数据包丢掉,大量的丢包会极大的浪费网络资源
+ 所以要进行流量控制
+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729574029416-1c487121-0b49-497c-9f36-286a5fa9c395.png)

<h4 id="uFlOh">特殊控制</h4>
一开始,接收给发送方发送了0窗口的报文段

后面,接收方又有了一些存储空间,给发送方发送的非0窗口的报文段丢失了

发送方的发送窗口一直为零,双方陷入僵局

**解决方案**

当发送方收到0窗口通知时,这是发送方停止发送报文

并且同时开启一个定时器,隔一段时间就发送一个测试报文去问询问接收方最新的窗口大小

<h3 id="mVbpS">拥塞控制</h3>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729579983786-aa28f0d1-f1dd-4c40-a8d4-fae53cc2879a.png)

<h4 id="vD31F">拥塞控制</h4>
+ 为防止 过多的数据注入到网络中
+ 避免网络中的路由器或链路过载
+ 拥塞控制是一个全局性的过程
+ 以及与降低网络传输性能有关的所有因素
+ 相比而言,流量控制是点对点通信的控制 

<h4 id="iuVG0">拥塞控制 - 方法</h4>
1. 慢开始(slow start ,慢启动)
2. 拥塞避免(congestion avoidance)
3. 快速重传(fast retransmit)
4. 快速恢复(fast recovery)

<h4 id="VhuDO">缩写名称</h4>
+ MSS(Maximum segment Size) 每个段做大的数据部分大小(在建立连接时)
+ cwnd(congestion window):拥塞窗口
+ rwnd(receive window):接收窗口
+ swnd(send window) :发送窗口( swnd =min(cwnd，rwnd))

<h4 id="LJpiL">慢开始</h4>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729585896423-9c4f9308-b06c-4cf8-a342-8f12e53eb637.png)



![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729689848546-5a827075-3bcf-47d4-b905-7b3ff7f4c347.png)

cwnd的初始值比较小,然后随着数据包被接收方确认(收到一个ack)

cwnd就成倍增长(指数级)

<h4 id="CiaEF">拥塞避免</h4>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729586279634-d0d8829b-9ee6-4887-bcf2-7dd1082c2b7b.png)

+ ssthresh(slow start threshold):慢开始阈值,cwnd达到阈值后,以线性方式增加
+ 拥塞避免(加法增大):拥塞窗口缓慢增大.,以防止网络过早出现堵塞
+ 乘法减小:只要网络出现堵塞,把ssthresh减半,于此同时,执行慢开始算法(cwnd又恢复到初始值)
+ 当网络出现频繁拥塞时,ssthresh值就下降的很快

<h4 id="IiuR0">快重传</h4>
+ **接收方**
    - 每收到一个失序列的分组后就立即发出重复确认
    - 使发送方及时知道有分组没有到达
    - 而不是等待自己发送数据时才进行确认
+ **发送方**
    - 只要连续 收到三个重复确认(总共4个相同的确认),就应当立即重传对方尚未收到的报文段
    - 而不必继续等待重传计时器到期后再重传

+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729587554623-5f3b2645-4e31-45a8-8b26-76db7c9245dc.png)

<h4 id="Kk5Hb">快重传 +  快恢复 </h4>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729781289848-5e416658-b64a-41e0-93a7-0a8b2b3c220c.png)

+ **快恢复**
    - 当发送方连续收到三个重复确认,就执行 "乘法减小" 算法，吧ssthresh减半
    - 这是为了预防网络拥塞
    - 由于发送方现在认为网络很可能没有发生拥塞
    - 因此,与慢开始不同之处是现在不执行慢开始算法,即cwnd现在不回复到初始值
    - 而是吧cwnd值设置为ssthresh减半后的数值
    - 然后开始执行拥塞避免算法( ' 加法增大 ' ),使拥塞窗口缓慢地线性增大
+ TCP - 拥塞避免 -发送窗口的最大值

<h4 id="sXv6G">发送窗口的最大值 </h4>
+ 发送窗口的最大值 :swnd=min(cwnd,rwnd) 谁小用谁
+ 让rwnd(接收窗口)< cwnd(拥塞窗口)时,是接收方的接受能力限制发送窗口的最大值
+ 当 cwnd < rwnd时,则是网络的拥塞限制发送窗口的最大值

<h3 id="Gq8s4">连接管理</h3>
<h4 id="lV5tj">建立连接</h4>

1. **三次握手**
+ CLOSE: client 处于关闭状态
+ LISTEN:server处于监听状态 等待client连接
+ SYN-RCVD:表示server接收到SYN报文,当收到client的ACK报文后,他会进入到ESTABLISHED状态
+ SYN-SENT:表示client已发送SYN报文,等待server的第二次握手
2. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730093568104-1ad45e0c-6a82-4876-a08c-76a9fefe7bb0.png)
3. 前两次握手
+ SYN都设置为1
+ 数据部分的长度都为0
+ TCP头部的长度一般是32字节
    - 固定头部:20字节
    - 选项部分:12字节
4. 双方会交换确认一些信息
5. 比如MSS 是否支持SACK Window scale(窗口缩放系数) 等
6. 这些数据都放在了TCP头部的选项部分中(12字节)
7. **TCP- 建立连接 --疑问**
    1. 为什么建立连接的时候,要进行三次握手,二次不行吗?
        1. 主要目的:防止server端一直等待,浪费资源
    2. 如果建立连接只需要两次握手,可能会出现的情况
    3. 结社client发出的第一个连接请求报文段,应为网络延迟,在连接释放以后的某个时间才到达server
    4. 本来这是一个早已失效的连接请求,但server收到此失效的请求后,误认为是client再次发送一个新的连接请求
    5. 于是server就会像client发出取人报文段,同意建立连接
    6. 如果不采用"三次挥手"，那么只要server发出确认,新的连接就建立了
    7. 由于现在client并没有真正想连接服务器的意愿,因此不会理财server的确认,也不会向server发送数据
    8. 但server却以为新的连接已经建立,并一直等待clinet发送数据,这样,server的很多资源就白白浪费掉了’
8. 采用 "三次握手" 的方法可以防止上述现象发生
9. 例如上述情况,client没有向server的确认发出确认,server由于收不到确认,就知道client并没有要求建立连接
10. 第三次握手失败了怎么处理
    1. 此时server的状态为SYN-RCVD,若等不到client的ack,server会重新发送SYN+ACK包
    2. 如果server多次重发SYN+ACK都等不到client的ACK,就会发送RST包,强制关闭连接
    3. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730220699231-4d072ad9-8750-4a64-bcd7-ffaf6115010d.png)
    4. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730278148200-8f8951e2-0ac4-4e77-924c-5ba407bc4f8a.png)
    5. ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730278154226-5eae7919-3633-467e-a99a-81f121541c09.png)

<h4 id="fBNrS">释放连接</h4>

<h5 id="Mrdax">四次挥手</h5>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730278683259-052343c5-8ae0-47c0-ab69-933195af7da4.png)

+ 为什么释放连接的时候,要进行四次挥手
+ T CP是全双工模式
+ 第一次挥手:<font style="color:#1DC0C9;">主机1</font>发送FIN报文段时<font style="color:#74B602;"></font>
    - 表示<font style="color:#1DC0C9;">主机1</font>告诉<font style="color:#74B602;">主机2</font>,<font style="color:#1DC0C9;">主机1</font>已经没有数据要发送了,但是,此时<font style="color:#1DC0C9;">主机1</font>还是可以接受来自<font style="color:#74B602;">主机2</font>的数据
+ 第二次挥手:当<font style="color:#74B602;">主机2</font>返回ACK报文段时
    - 表示<font style="color:#74B602;">主机2</font>已经知道<font style="color:#1DC0C9;">主机1</font>没有数据发送了,但是<font style="color:#74B602;">主机2</font>还是可以发送数据到<font style="color:#1DC0C9;">主机1</font>的
+ 第三次挥手:当<font style="color:#74B602;">主机2</font>也发送了FIN报文段时
    - 表示主机2告诉<font style="color:#1DC0C9;">主机1</font>,<font style="color:#74B602;">主机2</font>已经没有数据要发送了
+ 第四次挥手:当<font style="color:#1DC0C9;">主机1</font>返回ACK报文段时
    - 表示<font style="color:#1DC0C9;">主机1</font>已经知道<font style="color:#74B602;">主机2</font>没有数据发送了,随后正式断开整个TCP连接

<h4 id="OYgWE">状态解读</h4>

+ FIN-WAIT-1:表示想主动关闭连接
    - 向对方发送FIN报文,此时进入到FIN-WAIT-1状态
+ CLOSE-WAIT:表示正在等待关闭
    - 当对方发送FIN给自己,自己会回应一个ACK报文给对方,此时则进入到CLOSE-WAIT状态
    - 在此状态下,需要考虑自己是否还有数据要发送给多方,如果没有,发送FIN报文给对方
+ FIN-WAIT-2:只要对方发送ACK确认后,主动方就会处于FIN-WAIT-2状态,然后等待对方发送FIN报文
+ CLOSING:一种比较罕见的例外状态
    - 表示你发送FIN报文后,并没有收到对方的ACK报文,反而却也收到了对方的FIN报文
    - 如果双方几乎在同时准备关闭连接的话,那么就出现了双方同时发送FIN报文的情况,也即会出现CLOSING状态
    - 表示双方都正在关闭SOCKET

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730302485071-44981ed6-22d7-4da2-a68f-a2dd9b4e12a4.png) 
+ LASE-ACK:被动关闭一方在发送FIN报文后,最后等待对方的ACK报文
    - 当收到ACK报文后,即可进入CLOSED状态了
+ TIME-WAIT:表示收到对方的FIN报文,并发送出了ACK报文,2MSL后即可进入CLOSED状态
    - 如果FIN-WAIT-1状态,收到对方同时带FIN标志的ACK标志的报文时
    - 可以直接进入到TIM-WAIT状态,而无须经过FIN-WAIT-2状态
+ CLOSED:关闭状态
    - 由于状态的事件比较短暂,所以很难用netstat命令看到,比如SYN-RCVD, FIN-WAIT-1等

<h5 id="q1RDv">细节</h5>

+ TCP/IP协议栈在设计上,允许任何一方先发起断开请求,当前说的是client主动要求断开
+ client发送ACK后,需要有一个TIME-WAIT阶段,等待一段时间后,在真正关闭连接 
+ 一般是等待2倍的MSL(Maximum Segment Lifetime,最大分段生存期)
    - MSL是TCP报文在internet上的最长生存时间
    - 每个具体的TCP实现都必须选择一个确定的MSL值, [RFC 1122](https://www.rfc-editor.org/rfc/rfc1122)建议是2分钟
    - 可以防止本次连接中产生的数据包误传到下一次连接中(应为本次连接中的数据包都会在2MSL时间内消失了)
+ 如果client发送ACK后马上释放了,然后又因为网络原因,server没有收到client的ACK,server就会重发FIN
+ 这时可能出现的情况是
    - 1. client没有任何行营,服务器那边回干等,甚至多次重发FIN，浪费资源
    - 2.client有个新的应用程序刚好分配了同一端口号,新的应用程序收到FIN后马上开始执行断开连接的操作,本来他可能是想跟server建立连接的 

<h5 id="uRRML">抓包	</h5>

+ 有的时候在使用抓包工具的时候,有可能只看到  三次  挥手
+ 这其实是将第2,3此挥手合并了

+ ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730380078806-6f7984c0-3e0b-4575-9f00-1ff24ec75ae7.png)
+ 当server接收到client的FIN时,如果server后面也没有数据要发送给client了
+ 这时,server就可以将第2,3此挥手合并,同时告诉client两件事
    - 已经知道client没有数据要发
    - server已经没有数据要发了

    - ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730380836863-d7b1ccc8-44e0-4323-8c85-52876c3ee587.png)



<h3 id="x7M3H">TCP问题</h3>
+ **如果有个包重传了N次还是失败,会一直重传到成功个为止吗?**
+ 这个取决于系统的设置,比如有些系统,重传5次还未成功就会发送reset报文(RST)断开TCP连接

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1729563177309-b1b37066-8718-4745-82a3-1298404515ff.png)

+ **为什么选择在传输层就将数据"大卸八块" 分成多段,而不是等到网络层在分片传递给数据链路层**
+ 应为可以提高重传的性能
+ 需要明确的是:可靠传输是在传输层控制的
+ 如果在传输层不分段,一旦出现数据丢失,整个传输层的数据都得重传
+ 如果在传输层分了段,一旦出现数据丢失,只需要重传丢失的那段即可
+ **长连接和短链接是如何区分的**
+ 短连接在发送后会立即关闭
+ 长连接是开发者定义如何关闭

<h1 id="ImYbl">应用层</h1>
<h2 id="ePrEw">应用层的常见协议</h2>
+ 超文本传输:HTTP ,HTTPS
+ 文件传输:FTP
+ 邮件协议:SMTP POP2 IMAP
+ 动态主机配置:DHCP
+ 域名协议:DNS
+ 等

<h2 id="LjJ2g">域名(Domain Name)</h2>
+ 由于ip地址不方便记忆,并且不能表达组织的名称和性质,人们设计出了域名(比如baidu.com)
+ 但实际上,为了能够访问具体的主机,最终还是需要知道目标主机的ip地址



+ **域名可分为**
+ 顶级域名
+ 二级域名
+ 三级域名

<h3 id="MRJjf">顶级域名的分类</h3>
+ 通用的顶级域名(General Top-level Domain 简称gTLD)
    - .com(公司) .net(网络机构) ..org(组织机构) .edu(教育) .gov(政府部门) .int(国际组织)等



+ 国家及地区顶级域名(Country Code Top-level Domain 简称gTLD)
    - .cn(中国) .jp(日本) .uk(英国)



+ 新通用顶级域名(New Generic Top-level Domain 简称gTLD)
    - .vip .xyz .top club .shop等

<h3 id="RtkPU">二级域名</h3>
+ 二级域名是指顶级域名之下的域名
    - 在通用顶级域名之下,他一般指域名注册人的名称 例如 google baidu microsoft等
    - 在国家及地区顶级域名下,一般指注册类别的,例如com edu gov net 等

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730392286406-63c1d5f3-e8e9-4fb0-884a-8e936b55d44e.png)

<h3 id="w5lYN">DNS</h3>
DNS的全称是:Domain Name System 译为:域名系统

利用DNS协议,可以将域名(比如baidu.com)解析成对应的ip地址(比如 220.180.25.14）

DNS可以基于UDP协议,也可以基于TCP协议 ,服务器占用53端口

 ![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730393084017-1862414d-154b-4a7d-b5c7-0666e97075f3.png)

<h4 id="JHLSh">DNS命令</h4>
+ ipconfig/displaydns :查看DNS缓存记录
+ ipconfig/flushdns:清空DNS缓存记录
+ ping 域名
+ nslookup 域名

<h4 id="Ynfmb">DNS服务器</h4>
+ 客户端首先会访问最近的一台DNS服务器(也就是客户端自己配置的DNS服务器)
+ 所有的DNS服务器都记录了DNS根域名服务器的IP地址
+ 上级DNS服务器记录了下一级DNS服务器的IP地址
+ 全球一共13台ipv4的DNS根域名服务器,25太ipv6的DNS根域名服务器

<h3 id="zIaTS">IP地址的分配</h3>
+ IP地址分配方式,可以分为:静态ip地址,动态ip地址
+ 静态ip地址
    - 手动设置
    - 适用场景:不怎么挪动的台式机(比如学校机房中的台式机),服务器等
+ 动态ip地址w我
+ 
    - 从DHCP服务器自动获取ip地址
    - 使用场景:移动设备,无线设备等

<h3 id="qkqvT">DHCP</h3>
DHCP(Dynamic Host Configuration Protocal) 译为:动态主机配置协议

DHCP协议基于UDP协议,客户端端口是68端口,服务器端口是67端口

DHCP服务器会从ip地址池中,挑选一个ip地址"出租"给客户端一段时间,时间到期就回收他们

平时家里上网的路由器就可以充当DHCP服务器

<h4 id="qPObw">DHCP 分配IP地址的4个阶段</h4>
+ DISCOVER:发现服务器
    - 发广播包(源IP是0.0.0.0,目标IP是255.255.255.255 ,目标MAC是FF:FF:FF:FF:FF:FF)
+ OFFER:提供租约
    - 服务器返回可以租用的IP地址,以及租用期限,子网掩码,网关,DNS等信息
    - 可能会有多个服务器提供租约
+ REQUEST:选择IP地址
    - 客户端选择一个OFFER,发送广播包进行回应
+ ACKNOWLEDGE:确认
    - 被选中的服务器发送ACK数据包给客户端

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730703361968-90d56ef0-9d97-4fca-8b5c-a6f564f88ac6.png)

<h4 id="G6HAw">DHCP细节</h4>
DHCP服务器可以跨网段分配地址,可以借助DHCP中继代理(DHCP Relay Agent) 实现跨网段分配IP地址

+ 自动续约
    - 客户端会在租期不足的时候,自动想DHCO服务器发送REQURET信息申请续约
+ 常用命令
+ ipconfig /all:可以看到DHCP相关的详细信息,比较租约过期时间,DHCP服务器地址等
+ ipconfig /release :释放租约
+ ipconfig /renew :重新申请IP地址,申请续约(延长租期)

<h3 id="JpiGc">HTTP</h3>
> HTTP(Hyper Text Transfer Protocol),译为超文本传输协议
>

+ 是互联网中应用最广泛的应用层协议
+ 设计HTTP最初的目的是,提供一种发布和接受HTML页面的方法,由URI来表示具体的资源
+ 后面用HTTP来传递的数据格式不仅仅是HTML,应用非常广泛
+ HTML(Hyper Text Markop Language):超文本标记语言
+ 用以编写网页

<h4 id="McRcH">版本</h4>
+ 1991年,HTTP/0.9
    - 只支持GET请求方法获取文本数据(比如HTML文档),且不支持请求头,响应头等,无法向服务器传递太多信息
+ 1996年,HTTP/1.0
    - 支持POST,HEAD等请求方式i，支持请求头,响应头等,支持更多种数据类型(不在局限于文本数据)
    - 浏览器的每次请求都需要与服务器建立一个连接TCP连接,请求处理完毕后立即断开TCP连接
+ 1997年,HTTP/1.1(经典皮肤)
    - 支持PUT,DELETE等请求方法
    - 采用持久连接(Connection:keep-alive),多个请求可以共用一个TCP连接
+ 2015年,HTTP/2.0
+ 2018年,HTTP/3.0

<h4 id="nOWqK">标准</h4>
HTTP的标准

+ 有万维网协会(W3C),互联网工程任务组(IETF)协议制定,最终发布一系列的RFC
+ RFC(Request For Comments)请求意见稿

HTTP1.1规范

+ 最早在1997年的RFC 2068中记录的
+ 1999年RFC 2068作废 就在RFC 2616中
+ 2014年又由RFC 7230系列RFC取代

HTTP2 标准

+ 与2015年一RFC 7540发表取代HTTP1.1成为HTTP的实现标准

中国的RFC

+ 1996年3月,清华大学提交的使用不同国家和地区中文编码的汉字统一传输标准呗IETF通过为RFC 1922
+ 成为中国大陆第一个被认可为RFC文件的提交协议

<h4 id="Ykkzc">报文格式</h4>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730817687149-a6b26350-15e3-414c-a82e-09574e867e66.png)





<h4 id="t86wH">ABNF</h4>
ABNF (Augmented BNF)

是BNF (Backus -Naur Form 译为:巴克斯-<font style="color:black;">瑙尔范式</font>)的修改 增强版

在RFC 5234中表明:ABNF作用internet中通信协议的定义语言

ABNF 是最严谨的HTTP报文格式描述形式,脱离ABNF谈论HTTP报文格式,往往都是片面,不严谨的



关于HTTP报文格式ide定义

RFC 2616 4.HTTP Message (旧)

RFC 7230 3.Message Format(新)



<h4 id="oblRd">报文格式-整体</h4>


![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730821882771-8bd20878-e532-4864-be22-5431f195eb72.png)

<h4 id="DHzBW">ABNF-核心规则</h4>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730821930596-430f65c1-58d4-4c5b-8497-0b85640a729d.png)

<h4 id="Bb1c0">报文格式 -request-line  start-line</h4>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730822600477-bfc69aae-72d2-43a6-9e52-b3525978e4a3.png)

<h4 id="zD5jI">报文格式 - header-filed ,message-body</h4>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730823056312-1c94e510-345c-41d3-bcaa-ff58c002f4fa.png)

<h4 id="sCUGq">URL的编码</h4>
URL中一旦出现一些特殊的字符(比如中文,英文),需要进行编码

在浏览器地址输入URL时,是采用UTF-8进行编码

<h4 id="bjw8X">telnet</h4>
使用telnet命令可以直接面向HTTP报文与服务器交互

可以更清晰,直观地看到请求报文,响应报文的内容

可以检验请求报文格式的正确与否

<h4 id="fjjEe">请求方法</h4>
REF 7231 描述了 8中请求方法

GET POST PUT DELETE HEAD OPTIONS TRACE CONNECT

REF 5789  描述了PATCH方法

+ GET:常用于读取的操作,请求参数直接拼接在URL的后面(浏览器对URL是有长度限制的)
+ POST:冲用于添加 修改 删除的操作,请求参数可以直接放在请求体中(没有大小限制)
+ HEAD :请求得到与GET请求相同的响应,但没有响应体
    - 使用场景:在下载一个大文件前,先获取其大小,再决定是否要下载,以此可以节约带宽资源
+ OPTIONS:用于获取目的资源所支持的通信选项,比如服务器支持的请求方法
+ OPTIONS HTTP/1.1
+ PUT : 用于对已存在的资源进行整体覆盖  <font style="color:#DF2A3F;">不安全</font>
+ PATCH:用于对资源进行部分修改(资源不存在,会创建新的资源)    <font style="color:#DF2A3F;">不安全</font>
+ DELETE:用于删除指定的资源    <font style="color:#DF2A3F;">不安全</font>
+ TRACE:请求服务器会先其收到的请求信息 ,只要用于HTTP请求的测试和诊断
+ CONNECT:可以开启一个客户端与所请求资源之间的而双向沟通的通道,它可以用来创建渠道(tunnel)
    - 可以用来访问采用了SSL (HTTPS) 协议的站点

<h4 id="ArYLd">头部字段(Header Field)</h4>

+ 头部字段可以分为4种类型
+ 请求头字段(Request Header Fields)
    - 有关要获取的资源或客户端本身信息的消息头
+ 响应头字段(Request Header Fields)
    - 有关响应的补充信息,比如服务器本身(名称和版本等)的消息头
+ 是实体头字段(Entity Header Fields)
    - 有关实体主题的更多信息,比如主体长度(Conteng-Length)或其MIME类型
+ 通用头字段(General Header Fields)
    - 同时使用与请求和响应消息,但与消息主体无关的消息头、

<h4 id="INOwl">请求头字段</h4>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730899985201-b7e00e8e-4d69-4368-b30c-e25a0971109e.png)![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730904365778-b11f0a97-285f-45f4-9326-634bf2eeb1be.png)![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730904675216-aaa5c34a-222c-46e1-ac9b-f538e72ed5b0.png)

<h4 id="n82Hv">响应头字段</h4>

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730905165836-15a24bab-613e-40b4-beea-f7ced613470e.png)

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730905177280-9d3040c9-dfc8-4236-9e0e-57dc01dd3de5.png) 

![](https://cdn.nlark.com/yuque/0/2024/png/26748482/1730906179990-40df3b96-7d88-4237-a1a5-56fddb354456.png)

